// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

enum UserRole {
  USER
  MERCHANT
  MODERATOR // Nuovo ruolo: può approvare rilascio fondi e gestire dispute, ma meno controllo di ADMIN
  ADMIN
  HUB_STAFF // Staff del centro hub per gestione depositi e verifiche
  ESCROW_AGENT // Agente escrow autorizzato dall'admin per confermare pagamenti ricevuti in Verified Escrow
}

enum ListingType {
  SALE
  TRADE
  BOTH
}

enum CardCondition {
  MINT
  NEAR_MINT
  EXCELLENT
  GOOD
  PLAYED
  POOR
}

enum ProposalStatus {
  PENDING
  ACCEPTED
  REJECTED
  CANCELLED
}

enum EscrowType {
  LOCAL // Escrow locale (negozio fisico)
  VERIFIED // Verified Escrow (hub centrale SafeTrade)
}

enum SafeTradeStatus {
  PENDING
  CONFIRMED
  COMPLETED
  CANCELLED
  // Verified Escrow specific statuses
  PENDING_ESCROW_SETUP
  ESCROW_ACTIVE
  AWAITING_HUB_RECEIPT
  HUB_RECEIVED
  VERIFICATION_IN_PROGRESS
  VERIFICATION_PASSED
  VERIFICATION_FAILED
  SHIPPED_TO_BUYER
  IN_TRANSIT_TO_BUYER
  DELIVERED_TO_BUYER
  CONFIRMED_BY_BUYER
  RELEASE_REQUESTED
  RELEASE_APPROVED
  RETURNED_TO_SELLER
  REFUND_PENDING
  REFUNDED
}

enum HubPackageStatus {
  PENDING // In attesa di spedizione seller
  IN_TRANSIT_TO_HUB // Seller ha spedito, in transito verso hub
  RECEIVED_AT_HUB // Ricevuto all'hub (marcato da HUB_STAFF)
  VERIFICATION_IN_PROGRESS // Team sta verificando
  VERIFICATION_PASSED // Verifica OK, carta conforme
  VERIFICATION_FAILED // Verifica fallita (danni, non conforme)
  SHIPPED_TO_BUYER // Rispedito a buyer
  IN_TRANSIT_TO_BUYER // In transito verso buyer
  DELIVERED_TO_BUYER // Consegnato a buyer (tracking conferma)
  CONFIRMED_BY_BUYER // Buyer ha confermato ricezione
  RETURNED_TO_SELLER // Restituito a seller (verifica fallita)
  LOST_IN_TRANSIT // Perso in transito (disputa)
}

enum CardGame {
  POKEMON
  MAGIC
  YUGIOH
  ONEPIECE
  DIGIMON
  OTHER
}

model User {
  id              String   @id @default(cuid())
  email           String   @unique
  passwordHash    String
  name            String?
  avatar          String?
  role            UserRole @default(USER)
  city            String // User's city for geographic filtering (REQUIRED)
  province        String? // Province/region
  maxDistance     Int      @default(50) // Maximum distance in km for shop filtering (default 50km)
  bio             String? // User's passion description (Onboarding)
  preferredShopId String? // Preferred SafeTrade store
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  listings                 ListingP2P[]
  proposalsSent            Proposal[]               @relation("Proposer")
  proposalsReceived        Proposal[]               @relation("Receiver")
  safeTradeTransactionsAsA SafeTradeTransaction[]   @relation("UserA")
  safeTradeTransactionsAsB SafeTradeTransaction[]   @relation("UserB")
  shop                     Shop?
  notifications            Notification[]
  tournamentRegistrations  TournamentRegistration[]
  messagesSent             Message[]                @relation("Sender")
  messagesReceived         Message[]                @relation("Receiver")
  conversationsAsUserA     Conversation[]           @relation("ConversationUserA")
  conversationsAsUserB     Conversation[]           @relation("ConversationUserB")
  merchantApplication      MerchantApplication?

  // Escrow relations
  escrowSessionsAsBuyer       EscrowSession[]      @relation("EscrowBuyer")
  escrowSessionsAsSeller      EscrowSession[]      @relation("EscrowSeller")
  escrowSessionsAsMerchant    EscrowSession[]      @relation("EscrowMerchant")
  escrowMessagesSent          EscrowMessage[]      @relation("EscrowMessageSender")
  escrowWallet                EscrowWallet?        @relation("EscrowWallet")
  escrowHub                   EscrowHub?           @relation("EscrowHubProvider")
  escrowHubReviews            EscrowHubReview[]    @relation("EscrowHubReviewer")
  verificationReportsVerified VerificationReport[] @relation("VerificationReportVerifier")
  escrowAuditLogsPerformed    EscrowAuditLog[]     @relation("EscrowAuditLogPerformer")

  // Community Relations
  posts         Post[]
  comments      Comment[]
  badges        UserBadge[]
  postVotes     PostVote[]    @relation("PostVotes")
  commentVotes  CommentVote[] @relation("CommentVotes")
  createdTopics Topic[]       @relation("SubredditCreator")

  // Premium & Subscription
  subscription       UserSubscription?
  karma              UserKarma?
  priceAlerts        PriceAlert[]
  eventRegistrations EventRegistration[]

  // Contact Support
  contactMessages ContactMessage[] @relation("ContactMessages")

  // Dispute relations
  disputesOpened  Dispute[]        @relation("DisputeOpener")
  disputeMessages DisputeMessage[] @relation("DisputeMessageSender")
  packages        Package[]        @relation("PackageSeller")

  // Approvazione Manuale Rilascio Fondi
  pendingReleasesAsRecipient PendingRelease[]    @relation("PendingReleaseRecipient")
  pendingReleasesApproved    PendingRelease[]    @relation("PendingReleaseApprover")
  pendingReleasesRejected    PendingRelease[]    @relation("PendingReleaseRejecter")
  financialAuditLogs         FinancialAuditLog[] @relation("AuditPerformer")
  adminNotificationsActioned AdminNotification[] @relation("NotificationActioner")

  // Escrow Agent authorization
  escrowAgentAuth            EscrowAgentAuthorization?  @relation("EscrowAgentAuth")
  escrowAgentAuthorizations  EscrowAgentAuthorization[] @relation("EscrowAgentAuthorizer")

  // Vault relations
  vaultDeposits           VaultDeposit[]
  vaultItemsOwned         VaultItem[]        @relation("VaultItemOwner")
  vaultOrdersAsBuyer      VaultOrder[]
  vaultSplitsAsOwner      VaultSplit[]       @relation("VaultSplitOwner")
  vaultAuditLogs          VaultAuditLog[]
  vaultCaseRequests       VaultCaseRequest[] @relation("VaultCaseRequestUser")
  securityAuditLogs       SecurityAuditLog[] @relation("SecurityAuditAttemptedBy")

  @@index([email])
  @@index([role])
  @@index([city])
}

model Shop {
  id          String   @id @default(cuid())
  name        String
  slug        String?  @unique // URL-friendly identifier for subdomain (e.g., "nomenegozio")
  description String?
  logo        String?
  coverImage  String?
  images      String[] // Array of additional shop images for gallery
  address     String?
  city        String?
  latitude    Float? // Latitude for geolocation
  longitude   Float? // Longitude for geolocation
  postalCode  String?
  phone       String?
  email       String? // Shop email
  website     String? // Shop website
  rating      Float    @default(0)
  ratingCount Int      @default(0)
  merchantId  String   @unique
  merchant    User     @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  isApproved  Boolean  @default(false) // Manual approval required

  // Opening hours (JSON string: {"monday": {"open": "09:00", "close": "18:00", "closed": false}, ...})
  openingHours String?

  // Social media links
  facebookUrl  String?
  instagramUrl String?
  twitterUrl   String?
  youtubeUrl   String?
  tiktokUrl    String?

  // Fee split configuration
  platformFeeShare Float @default(10.0) // % della fee che va alla piattaforma (default 10% della fee totale)
  // Esempio: fee 5% su trade €100 = €5 fee totale. platformFeeShare 10% = €0.50 alla piattaforma, €4.50 al merchant

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  products      Product[]
  transactions  SafeTradeTransaction[]
  importBatches ImportBatch[]
  tournaments   Tournament[]
  apiKey        String?                @unique // For Chrome extension
  // Note: Full-text index will be created manually via SQL after db:push
  promotions    Promotion[]

  // Vault relations
  vaultEnabled          Boolean            @default(false) // Partecipa al programma Vetrina Vault
  vaultCaseAuthorized   Boolean            @default(false) // Ha pagato e ha teca autorizzata (può usare scansione QR)
  vaultCase             VaultCase?         @relation("ShopVaultCase") // Teca autorizzata (one-to-one)
  vaultCases            VaultCase[]        @relation("VaultCaseShop") // Teche assegnate (possono essere multiple)
  vaultItems            VaultItem[]        @relation("VaultItemShop")
  vaultOrders           VaultOrder[]
  vaultSales            VaultSale[]
  vaultSplitsAsMerchant VaultSplit[]       @relation("VaultSplitMerchant")
  vaultCaseRequests     VaultCaseRequest[] @relation("VaultCaseRequest")

  // Merchant ledger & invoicing
  merchantLedgerEntries MerchantLedgerEntry[]
  merchantInvoices      MerchantInvoice[]

  @@index([merchantId])
  @@index([name])
  @@index([slug])
  @@index([city])
  @@index([isApproved])
  @@index([vaultEnabled])
}

// ============= ESCROW HUB (PERSONAL ESCROW SERVICE) =============

model EscrowHub {
  id         String @id @default(cuid())
  providerId String @unique // User who provides escrow service
  provider   User   @relation("EscrowHubProvider", fields: [providerId], references: [id], onDelete: Cascade)

  // Hub Information
  name        String // Hub name (e.g., "Mario's Escrow Hub")
  description String? // Description of services

  // Address (home address for package receiving)
  address    String
  city       String
  province   String?
  postalCode String?
  country    String  @default("IT")

  // Contact
  phone String?
  email String? // Contact email

  // Hub Status
  isActive   Boolean @default(true)
  isApproved Boolean @default(false) // Manual approval required
  isVerified Boolean @default(false) // Identity verified by admin

  // Ratings & Stats
  rating                Float @default(0) // Average rating (0-5)
  ratingCount           Int   @default(0) // Number of ratings
  transactionsCompleted Int   @default(0) // Total transactions completed

  // Service Settings
  serviceFee        Float    @default(5.0) // Service fee percentage (default 5%)
  maxPackageValue   Float? // Maximum package value accepted (null = no limit)
  acceptedCountries String[] // Countries from which packages are accepted (empty = all)

  // Availability
  isAvailable Boolean @default(true) // Currently accepting new packages

  // Admin Review
  reviewNotes String? // Admin review notes
  reviewedAt  DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  transactions SafeTradeTransaction[]
  reviews      EscrowHubReview[]

  @@index([providerId])
  @@index([city])
  @@index([isActive])
  @@index([isApproved])
  @@index([isAvailable])
  @@index([rating])
}

// Hub Reviews & Ratings
model EscrowHubReview {
  id            String    @id @default(cuid())
  hubId         String
  hub           EscrowHub @relation(fields: [hubId], references: [id], onDelete: Cascade)
  reviewerId    String // User who left review
  reviewer      User      @relation("EscrowHubReviewer", fields: [reviewerId], references: [id], onDelete: Cascade)
  transactionId String? // Related transaction (optional)

  rating  Int // 1-5 stars
  comment String?  @db.Text
  pros    String[] // Positive aspects
  cons    String[] // Negative aspects

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([hubId, reviewerId, transactionId])
  @@index([hubId])
  @@index([reviewerId])
  @@index([rating])
  @@index([createdAt])
}

model Product {
  id          String        @id @default(cuid())
  title       String
  description String?
  price       Float
  condition   CardCondition
  game        CardGame
  set         String? // Set name
  cardNumber  String? // e.g., "25/102"
  rarity      String? // Common, Rare, Ultra Rare, etc.
  language    String        @default("IT")
  images      String[] // Array of image URLs (Supabase Storage)
  isActive    Boolean       @default(true)
  stock       Int           @default(1)
  shopId      String
  shop        Shop          @relation(fields: [shopId], references: [id], onDelete: Cascade)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  // Note: Full-text and trigram indexes will be created manually via SQL after db:push

  @@index([shopId])
  @@index([game])
  @@index([isActive])
  @@index([price])
}

enum ListingVisibility {
  EARLY_ACCESS // Solo Premium per 24h
  PUBLIC // Tutti possono vedere
}

model ListingP2P {
  id            String        @id @default(cuid())
  title         String
  description   String?
  type          ListingType
  price         Float? // If sale or both
  condition     CardCondition
  game          CardGame
  set           String? // Set name
  cardNumber    String? // e.g., "25/102"
  rarity        String?
  language      String        @default("IT")
  images        String[] // Array of image URLs (Cloudinary)
  wants         String? // What they want in trade
  isActive      Boolean       @default(true)
  isSold        Boolean       @default(false) // Marcato come venduto quando transazione completata
  isApproved    Boolean       @default(false) // Manual approval required by admin
  approvalNotes String? // Admin notes for approval/rejection
  userId        String
  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  // Early Access System (Premium Feature)
  visibility     ListingVisibility @default(PUBLIC)
  earlyAccessEnd DateTime? // Timestamp fine early access (24h dopo creazione)

  // SafeVault Integration
  isVaultListing  Boolean   @default(false) // Se true, vendita in contovendita SafeVault
  vaultItemId     String?   @unique // Collegamento a VaultItem
  vaultItem       VaultItem? @relation("ListingVaultItem", fields: [vaultItemId], references: [id], onDelete: SetNull)
  vaultDepositId  String? // ID deposito da cui proviene (se da listing)

  proposals        Proposal[]
  featuredListings FeaturedListing[]
  alertTriggers    AlertTrigger[]
  // Note: Full-text and trigram indexes will be created manually via SQL after db:push

  @@index([userId])
  @@index([game])
  @@index([type])
  @@index([isActive])
  @@index([isSold])
  @@index([isApproved])
  @@index([price])
  @@index([createdAt])
  @@index([visibility])
  @@index([earlyAccessEnd])
  @@index([isVaultListing])
  @@index([vaultItemId])
}

model Proposal {
  id         String         @id @default(cuid())
  listingId  String
  listing    ListingP2P     @relation(fields: [listingId], references: [id], onDelete: Cascade)
  proposerId String
  proposer   User           @relation("Proposer", fields: [proposerId], references: [id], onDelete: Cascade)
  receiverId String
  receiver   User           @relation("Receiver", fields: [receiverId], references: [id], onDelete: Cascade)
  type       ListingType // SALE or TRADE
  offerPrice Float? // Counter-offer if sale
  tradeItems String? // Description of items offered in trade
  message    String? // Optional message from proposer
  feePaidBy  FeePaidBy      @default(SELLER) // Chi paga la commissione SafeTrade
  status     ProposalStatus @default(PENDING)
  createdAt  DateTime       @default(now())
  updatedAt  DateTime       @updatedAt

  transaction SafeTradeTransaction?

  @@index([listingId])
  @@index([proposerId])
  @@index([receiverId])
  @@index([status])
  @@index([createdAt])
}

enum PriorityTier {
  STANDARD // Free users
  PRIORITY // Premium users
  FAST_TRACK // PRO users
}

model SafeTradeTransaction {
  id         String    @id @default(cuid())
  proposalId String?   @unique
  proposal   Proposal? @relation(fields: [proposalId], references: [id], onDelete: SetNull)
  userAId    String
  userA      User      @relation("UserA", fields: [userAId], references: [id], onDelete: Cascade)
  userBId    String
  userB      User      @relation("UserB", fields: [userBId], references: [id], onDelete: Cascade)

  // Escrow Type
  escrowType EscrowType @default(LOCAL) // LOCAL o VERIFIED

  // Support for both Shop-based and Hub-based escrow
  shopId String? // Optional - for shop-based escrow (LOCAL)
  shop   Shop?      @relation(fields: [shopId], references: [id], onDelete: Restrict)
  hubId  String? // Optional - for hub-based escrow (VERIFIED - uses central hub)
  hub    EscrowHub? @relation(fields: [hubId], references: [id], onDelete: Restrict)

  scheduledDate    DateTime?
  scheduledTime    String? // Time slot (e.g., "10:00-11:00") - only for LOCAL
  status           SafeTradeStatus @default(PENDING)
  notes            String? // Notes from shop/hub or users
  verificationCode String? // Code for verification at store/hub
  completedAt      DateTime? // When transaction was completed
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt

  // Priority Queue System
  priorityTier PriorityTier @default(STANDARD)
  priorityPaid Boolean      @default(false) // Se ha pagato per priority (pay-per-use)

  // Hub Package Tracking (only for VERIFIED escrow)
  packageStatus        HubPackageStatus? // Status of package in hub
  trackingNumber       String? // Shipping tracking number (to hub)
  returnTrackingNumber String? // Return tracking number (to buyer)
  packageReceivedAt    DateTime? // When package received at hub
  packageVerifiedAt    DateTime? // When package verified at hub
  packageShippedAt     DateTime? // When package shipped to buyer
  packageDeliveredAt   DateTime? // When package delivered to buyer
  confirmedReceivedAt  DateTime? // When buyer confirmed receipt
  autoReleaseAt        DateTime? // When to auto-release funds (72h after delivery)
  verificationPhotos   String[] // Photos of package contents for verification
  verificationNotes    String?           @db.Text // Notes from hub staff verification
  conditionVerified    CardCondition? // Condition verified by hub staff
  priceFinal           Float? // Final price (if different from listing)

  // Relations
  escrowSession   EscrowSession?
  escrowPayment   EscrowPayment?
  pendingReleases PendingRelease[] @relation("PendingReleases")
  shippingLabel   ShippingLabel?   @relation("TransactionShippingLabel")
  merchantLedgerEntries MerchantLedgerEntry[]

  // Insurance, Disputes, Packages
  insurance      PackageInsurance?      @relation("PackageInsurance")
  disputes       Dispute[]              @relation("Disputes")
  packages       Package[]              @relation("Packages")
  consolidations PackageConsolidation[] @relation("Consolidations")

  @@index([userAId])
  @@index([userBId])
  @@index([shopId])
  @@index([hubId])
  @@index([status])
  @@index([scheduledDate])
  @@index([verificationCode])
  @@index([priorityTier])
  @@index([packageStatus])
}

model Notification {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  type      String // "proposal_received", "proposal_accepted", "transaction_confirmed", etc.
  title     String
  message   String
  link      String? // URL to related page
  data      Json? // Generic data field for structured info
  read      Boolean  @default(false)
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([read])
  @@index([createdAt])
}

model ImportBatch {
  id         String   @id @default(cuid())
  shopId     String
  shop       Shop     @relation(fields: [shopId], references: [id], onDelete: Cascade)
  source     String // "vinted", "cardmarket", "manual"
  status     String // "pending", "processing", "completed", "failed"
  itemsCount Int      @default(0)
  itemsData  Json? // Raw data from extension
  error      String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([shopId])
  @@index([status])
}

// ============= TOURNAMENTS =============

enum TournamentStatus {
  DRAFT
  PUBLISHED
  REGISTRATION_CLOSED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

model Tournament {
  id              String           @id @default(cuid())
  title           String
  description     String?
  game            CardGame
  shopId          String
  shop            Shop             @relation(fields: [shopId], references: [id], onDelete: Cascade)
  date            DateTime
  time            String // e.g., "14:00"
  maxParticipants Int
  entryFee        Float? // Optional entry fee
  prizePool       String? // Description of prizes
  rules           String? // Tournament rules
  status          TournamentStatus @default(DRAFT)
  winners         String? // Optional: names of winners (e.g., "1st: Mario Rossi, 2nd: Luigi Bianchi")
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  registrations TournamentRegistration[]

  @@index([shopId])
  @@index([game])
}

model TournamentRegistration {
  id           String     @id @default(cuid())
  tournamentId String
  tournament   Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  userId       String
  user         User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  status       String     @default("CONFIRMED") // CONFIRMED, CANCELLED, WAITLIST
  createdAt    DateTime   @default(now())

  @@unique([tournamentId, userId])
  @@index([tournamentId])
  @@index([userId])
}

// ============= FEATURED LISTINGS (VETRINA) =============

model FeaturedListing {
  id         String     @id @default(cuid())
  listingId  String
  listing    ListingP2P @relation(fields: [listingId], references: [id], onDelete: Cascade)
  startDate  DateTime   @default(now())
  endDate    DateTime
  tier       String     @default("BASIC") // BASIC (3 days), PREMIUM (1 week)
  amountPaid Float
  isActive   Boolean    @default(true)
  createdAt  DateTime   @default(now())

  @@index([listingId])
  @@index([endDate])
  @@index([isActive])
}

// ============= CHAT / MESSAGING =============

model Conversation {
  id        String   @id @default(cuid())
  userAId   String
  userA     User     @relation("ConversationUserA", fields: [userAId], references: [id], onDelete: Cascade)
  userBId   String
  userB     User     @relation("ConversationUserB", fields: [userBId], references: [id], onDelete: Cascade)
  listingId String? // Optional - conversation about a listing
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  messages Message[]

  @@unique([userAId, userBId])
  @@index([userAId])
  @@index([userBId])
}

model Message {
  id             String       @id @default(cuid())
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  senderId       String
  sender         User         @relation("Sender", fields: [senderId], references: [id], onDelete: Cascade)
  receiverId     String
  receiver       User         @relation("Receiver", fields: [receiverId], references: [id], onDelete: Cascade)
  content        String
  read           Boolean      @default(false)
  createdAt      DateTime     @default(now())

  @@index([conversationId])
  @@index([senderId])
  @@index([receiverId])
  @@index([read])
}

// ============= MERCHANT APPLICATION =============

enum ApplicationStatus {
  PENDING
  APPROVED
  REJECTED
}

model MerchantApplication {
  id          String            @id @default(cuid())
  userId      String            @unique
  user        User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  shopName    String // Nome azienda
  companyName String // Ragione sociale
  vatNumber   String // Partita IVA
  taxCode     String? // Codice fiscale
  uniqueCode  String? // Codice univoco azienda
  description String?
  address     String
  city        String
  province    String? // Provincia
  postalCode  String? // CAP
  phone       String
  email       String? // Email aziendale
  website     String? // Sito web
  documentUrl String? // Business license or ID
  legalForm   String? // Forma giuridica (SRL, SNC, ecc.)
  status      ApplicationStatus @default(PENDING)
  reviewNotes String? // Admin notes
  reviewedAt  DateTime?
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  @@index([status])
  @@index([createdAt])
  @@index([vatNumber])
}

// ============= ESCROW SYSTEM =============

enum EscrowSessionStatus {
  CREATED // Sessione creata, non ancora prenotata
  BOOKED // Slot prenotato, in attesa data appuntamento
  CHECKIN_PENDING // Data appuntamento arrivata, in attesa check-in
  CHECKED_IN // Merchant ha confermato presenza buyer+seller
  VERIFICATION_IN_PROGRESS // Verifica merchant in corso
  VERIFICATION_PASSED // Verifica superata
  VERIFICATION_FAILED // Verifica fallita
  RELEASE_REQUESTED // Rilascio fondi richiesto
  RELEASE_APPROVED // Rilascio fondi approvato (doppia conferma)
  COMPLETED // Sessione completata con successo
  DISPUTED // Dispute aperta (da vari stati)
  CANCELLED // Sessione cancellata (da CREATED/BOOKED)
  EXPIRED // Check-in non avvenuto entro 1 ora (da BOOKED/CHECKIN_PENDING)
}

enum FeePaidBy {
  SELLER // Fee detratta dal venditore (dal prezzo di vendita)
  BUYER // Fee aggiunta e pagata dal compratore
  SPLIT // Fee divisa 50/50 tra venditore e compratore
}

enum EscrowPaymentStatus {
  PENDING // Payment initiated but not confirmed
  HELD // Funds held in escrow
  RELEASED // Funds released to seller
  REFUNDED // Funds refunded to buyer
  CANCELLED // Payment cancelled
}

enum EscrowPaymentMethod {
  CASH // Cash payment at store
  ONLINE // Online payment (future)
  BANK_TRANSFER // Bank transfer (future)
}

// Escrow Session - Connects buyer, seller, and merchant in a communication session
model EscrowSession {
  id            String               @id @default(cuid())
  transactionId String               @unique
  transaction   SafeTradeTransaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)

  // Participants
  buyerId    String // User A (proposer)
  buyer      User   @relation("EscrowBuyer", fields: [buyerId], references: [id], onDelete: Cascade)
  sellerId   String // User B (receiver)
  seller     User   @relation("EscrowSeller", fields: [sellerId], references: [id], onDelete: Cascade)
  merchantId String // Shop owner
  merchant   User   @relation("EscrowMerchant", fields: [merchantId], references: [id], onDelete: Cascade)

  status EscrowSessionStatus @default(CREATED)

  // Appointment & Check-in
  appointmentSlot DateTime? // Slot prenotato (DateTime combinato da scheduledDate + scheduledTime)
  expiredAt       DateTime? // Scadenza per check-in (1 ora dopo appointmentSlot)
  checkInAt       DateTime? // Quando merchant ha fatto check-in
  buyerPresent    Boolean   @default(false) // Presenza buyer confermata da merchant
  sellerPresent   Boolean   @default(false) // Presenza seller confermata da merchant

  // Payment & Fee Management
  totalAmount   Float               @default(0) // Prezzo totale concordato
  feePercentage Float               @default(5.0) // Percentuale fee (default 5%)
  feePaidBy     FeePaidBy           @default(SELLER) // Chi paga la fee
  feeAmount     Float               @default(0) // Fee calcolata
  finalAmount   Float               @default(0) // Importo finale (dopo fee)
  paymentMethod EscrowPaymentMethod @default(CASH) // Solo CASH per ora

  // QR Code for in-store verification
  qrToken          String?   @unique // Token opaco per QR check-in
  qrTokenExpiresAt DateTime? // Scadenza token QR (7 giorni dalla creazione)
  qrScannedAt      DateTime? // Timestamp quando il QR è stato scannerizzato
  qrScannedBy      String? // ID del merchant che ha scannerizzato
  // Deprecated: qrCode (mantenuto per compatibilità)
  qrCode           String?   @unique // Deprecated - usare qrToken
  qrCodeExpiresAt  DateTime? // Deprecated

  // Session metadata
  lastActivity DateTime @default(now())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  messages           EscrowMessage[]
  verificationReport VerificationReport?
  auditEvents        EscrowAuditLog[]

  @@index([transactionId])
  @@index([buyerId])
  @@index([sellerId])
  @@index([merchantId])
  @@index([status])
  @@index([qrCode])
  @@index([qrToken])
  @@index([appointmentSlot])
  @@index([expiredAt])
  @@index([lastActivity])
}

// Messages within escrow session
model EscrowMessage {
  id        String        @id @default(cuid())
  sessionId String
  session   EscrowSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  senderId  String
  sender    User          @relation("EscrowMessageSender", fields: [senderId], references: [id], onDelete: Cascade)
  content   String
  isSystem  Boolean       @default(false) // System messages (e.g., "Payment received")
  readBy    String[] // Array of user IDs who read this message
  createdAt DateTime      @default(now())

  @@index([sessionId])
  @@index([senderId])
  @@index([createdAt])
}

// Verification Report - Report di verifica merchant con foto e note
enum VerificationStatus {
  IN_PROGRESS
  PASSED
  FAILED
}

model VerificationReport {
  id        String        @id @default(cuid())
  sessionId String        @unique
  session   EscrowSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  status VerificationStatus @default(IN_PROGRESS)

  // Photos (minimo 3 obbligatorie)
  verificationPhotos String[] // Array path foto in Supabase Storage
  photosMetadata     Json? // Metadata foto (dimensione, hash, width, height)

  // Notes
  notes String? @db.Text // Note merchant

  // Timestamps
  verifiedAt   DateTime?
  verifiedById String? // ID merchant che ha eseguito verifica
  verifiedBy   User?     @relation("VerificationReportVerifier", fields: [verifiedById], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([sessionId])
  @@index([status])
  @@index([verifiedById])
}

// Escrow Audit Log - Audit trail completo tutte le azioni
model EscrowAuditLog {
  id        String        @id @default(cuid())
  sessionId String
  session   EscrowSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  // Action details
  actionType      String // 'CHECK_IN', 'VERIFICATION_STARTED', 'VERIFICATION_PASSED', 'VERIFICATION_FAILED', 'RELEASE_REQUESTED', 'RELEASE_APPROVED', 'SESSION_EXPIRED', 'SESSION_EXTENDED', 'SESSION_CLOSED_MANUAL'
  performedById   String // ID utente che ha eseguito azione (può essere 'SYSTEM' per azioni automatiche)
  performedBy     User?  @relation("EscrowAuditLogPerformer", fields: [performedById], references: [id], onDelete: SetNull)
  performedByRole String // 'BUYER', 'SELLER', 'MERCHANT', 'ADMIN', 'MODERATOR', 'SYSTEM'

  // State transition
  oldStatus EscrowSessionStatus? // Stato prima della transizione
  newStatus EscrowSessionStatus? // Stato dopo la transizione

  // Metadata
  metadata  Json? // Dati aggiuntivi (es. { expiredAt: ..., extendedBy: ... })
  ipAddress String?
  userAgent String? @db.Text

  createdAt DateTime @default(now())

  @@index([sessionId])
  @@index([actionType])
  @@index([performedById])
  @@index([createdAt])
  @@index([oldStatus])
  @@index([newStatus])
}

// Escrow Payment - Manages funds in escrow
model EscrowPayment {
  id            String               @id @default(cuid())
  transactionId String               @unique
  transaction   SafeTradeTransaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)

  // Payment details
  amount        Float // Total amount in escrow
  currency      String              @default("EUR")
  paymentMethod EscrowPaymentMethod @default(CASH)
  status        EscrowPaymentStatus @default(PENDING)

  // Payment tracking
  paymentInitiatedAt DateTime? // When payment was initiated
  paymentHeldAt      DateTime? // When funds were held
  paymentReleasedAt  DateTime? // When funds were released to seller
  paymentRefundedAt  DateTime? // When funds were refunded

  // Payment references (for online payments)
  paymentProviderId String? // External payment provider transaction ID
  paymentProvider   String? // e.g., "stripe", "paypal"

  // Security & fraud prevention
  riskScore        Float? // Risk assessment score (0-100)
  flaggedForReview Boolean @default(false)
  reviewNotes      String? // Admin review notes

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([transactionId])
  @@index([status])
  @@index([paymentProviderId])
  @@index([flaggedForReview])
}

// Escrow Wallet - User's escrow balance (for future online payments)
model EscrowWallet {
  id     String @id @default(cuid())
  userId String @unique
  user   User   @relation("EscrowWallet", fields: [userId], references: [id], onDelete: Cascade)

  balance        Float @default(0) // Available balance
  pendingBalance Float @default(0) // Funds in pending transactions
  totalDeposited Float @default(0) // Total ever deposited
  totalWithdrawn Float @default(0) // Total ever withdrawn

  // Security
  isActive     Boolean  @default(true)
  lastActivity DateTime @default(now())

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  transactions EscrowWalletTransaction[]

  @@index([userId])
}

enum EscrowWalletTransactionType {
  DEPOSIT
  WITHDRAWAL
  ESCROW_HOLD // Funds held for transaction
  ESCROW_RELEASE // Funds released from escrow
  ESCROW_REFUND // Funds refunded from escrow
}

// Wallet transaction history
model EscrowWalletTransaction {
  id       String       @id @default(cuid())
  walletId String
  wallet   EscrowWallet @relation(fields: [walletId], references: [id], onDelete: Cascade)

  type        EscrowWalletTransactionType
  amount      Float
  description String?

  // Reference to related transaction/payment
  relatedTransactionId String? // SafeTradeTransaction ID
  relatedPaymentId     String? // EscrowPayment ID

  balanceBefore Float
  balanceAfter  Float

  createdAt DateTime @default(now())

  @@index([walletId])
  @@index([type])
  @@index([createdAt])
  @@index([relatedTransactionId])
}

// ============= PROMOTIONS =============

enum DiscountType {
  PERCENTAGE
  FIXED_AMOUNT
}

model Promotion {
  id            String       @id @default(cuid())
  shopId        String
  shop          Shop         @relation(fields: [shopId], references: [id], onDelete: Cascade)
  title         String
  description   String?
  discountType  DiscountType
  discountValue Float
  startDate     DateTime
  endDate       DateTime
  isActive      Boolean      @default(true)
  appliesTo     String[] // "ALL", "PRODUCTS", "LISTINGS"
  targetIds     String[] // IDs of specific items if appliesTo is specific
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt

  @@index([shopId])
  @@index([isActive])
  @@index([startDate])
  @@index([endDate])
}

// ============= COMMUNITY SYSTEM =============

model Topic {
  id          String   @id @default(cuid())
  slug        String   @unique
  name        String
  description String?
  icon        String? // Material symbol name
  posts       Post[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Premium Community (Insider Circle)
  isPremiumOnly Boolean @default(false)
  requiredTier  String? // "PREMIUM", "PRO", null = public

  // Subreddit-style features
  creatorId   String? // User who created this subreddit
  creator     User?   @relation("SubredditCreator", fields: [creatorId], references: [id], onDelete: SetNull)
  memberCount Int     @default(0) // Number of members
  rules       String? @db.Text // Subreddit rules
  bannerImage String? // Banner image URL
  isNSFW      Boolean @default(false) // Not Safe For Work flag

  @@index([creatorId])
  @@index([slug])
}

model Post {
  id        String    @id @default(cuid())
  title     String
  content   String    @db.Text
  topicId   String
  topic     Topic     @relation(fields: [topicId], references: [id], onDelete: Cascade)
  authorId  String
  author    User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  comments  Comment[]
  views     Int       @default(0)
  isPinned  Boolean   @default(false)
  isLocked  Boolean   @default(false)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  // Karma & Moderation System
  upvotes        Int     @default(0)
  downvotes      Int     @default(0)
  spamScore      Float   @default(0) // 0-1, higher = more likely spam
  isAutoApproved Boolean @default(false) // Auto-approved se karma utente > 50
  isFlagged      Boolean @default(false)
  flagReason     String?
  karmaChange    Int     @default(0) // Karma gained/lost from this post

  // Voting system
  votes PostVote[]

  @@index([topicId])
  @@index([authorId])
  @@index([createdAt])
  @@index([isFlagged])
  @@index([upvotes])
}

model Comment {
  id        String    @id @default(cuid())
  content   String    @db.Text
  postId    String
  post      Post      @relation(fields: [postId], references: [id], onDelete: Cascade)
  authorId  String
  author    User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  parentId  String? // For nested comments
  parent    Comment?  @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies   Comment[] @relation("CommentReplies")
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  // Voting system
  upvotes   Int           @default(0)
  downvotes Int           @default(0)
  votes     CommentVote[]

  @@index([postId])
  @@index([authorId])
  @@index([parentId])
}

// Voting models
model PostVote {
  id        String   @id @default(cuid())
  postId    String
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation("PostVotes", fields: [userId], references: [id], onDelete: Cascade)
  vote      Int // 1 for upvote, -1 for downvote
  createdAt DateTime @default(now())

  @@unique([postId, userId])
  @@index([postId])
  @@index([userId])
}

model CommentVote {
  id        String   @id @default(cuid())
  commentId String
  comment   Comment  @relation(fields: [commentId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation("CommentVotes", fields: [userId], references: [id], onDelete: Cascade)
  vote      Int // 1 for upvote, -1 for downvote
  createdAt DateTime @default(now())

  @@unique([commentId, userId])
  @@index([commentId])
  @@index([userId])
}

// ============= BADGES SYSTEM =============

model Badge {
  id          String      @id @default(cuid())
  name        String      @unique
  description String?
  icon        String // Material symbol or image URL
  color       String      @default("blue") // e.g., "blue", "red", "gold"
  users       UserBadge[]
  createdAt   DateTime    @default(now())
}

model UserBadge {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  badgeId   String
  badge     Badge    @relation(fields: [badgeId], references: [id], onDelete: Cascade)
  awardedAt DateTime @default(now())

  @@unique([userId, badgeId])
}

// ============= SUBSCRIPTION SYSTEM =============

enum SubscriptionTier {
  FREE
  PREMIUM
  PRO
}

enum SubscriptionStatus {
  ACTIVE
  CANCELLED
  EXPIRED
  PAST_DUE
}

enum BillingPeriod {
  MONTHLY
  YEARLY
}

model SubscriptionPlan {
  id           String           @id @default(cuid())
  name         String           @unique // "FREE", "PREMIUM", "PRO"
  tier         SubscriptionTier
  description  String?
  priceMonthly Float            @default(0)
  priceYearly  Float            @default(0)

  // Features
  earlyAccessHours     Int     @default(0) // 0 = no early access, 24 = 24h head start
  maxAlerts            Int     @default(3) // Max price alerts
  prioritySafeTrade    Boolean @default(false)
  instantNotifications Boolean @default(false)
  premiumCommunity     Boolean @default(false)
  bulkListingTools     Boolean @default(false)
  priorityMonthlyLimit Int     @default(0) // Free priority SafeTrades per month

  subscriptions UserSubscription[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model UserSubscription {
  id     String           @id @default(cuid())
  userId String           @unique
  user   User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  planId String
  plan   SubscriptionPlan @relation(fields: [planId], references: [id])

  status        SubscriptionStatus @default(ACTIVE)
  billingPeriod BillingPeriod      @default(MONTHLY)

  // Dates
  startDate   DateTime  @default(now())
  endDate     DateTime? // null = never expires (lifetime or free)
  cancelledAt DateTime?

  // Payment tracking (for future Stripe integration)
  stripeCustomerId     String?
  stripeSubscriptionId String?
  lastPaymentAt        DateTime?
  nextPaymentAt        DateTime?

  // Usage tracking
  priorityUsedThisMonth Int @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([planId])
  @@index([status])
  @@index([endDate])
}

// ============= KARMA SYSTEM =============

enum KarmaLevel {
  NEW // 0-49 karma
  TRUSTED // 50-199 karma
  ELITE // 200-499 karma
  LEGEND // 500+ karma
  BANNED // < 0 karma
}

model UserKarma {
  id     String @id @default(cuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  karma Int        @default(0)
  level KarmaLevel @default(NEW)

  // Activity tracking
  postsCount      Int @default(0)
  commentsCount   Int @default(0)
  upvotesGiven    Int @default(0)
  upvotesReceived Int @default(0)
  flagsReceived   Int @default(0)

  // Rate limiting
  lastPostAt    DateTime?
  postsToday    Int       @default(0)
  lastResetDate DateTime  @default(now())

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([karma])
  @@index([level])
}

// ============= PRICE ALERTS SYSTEM =============

model PriceAlert {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Alert conditions (any combination)
  cardName  String? // Specifica carta (fuzzy match)
  cardSet   String? // Specifico set
  game      CardGame?
  maxPrice  Float? // Alert se prezzo < maxPrice
  minPrice  Float? // Alert se prezzo > minPrice (for selling)
  rarity    String? // Alert per rarità
  condition CardCondition?

  // Notification settings
  notifyEmail Boolean @default(true)
  notifyPush  Boolean @default(false) // Solo Premium
  notifySMS   Boolean @default(false) // Solo PRO

  isActive        Boolean   @default(true)
  lastTriggeredAt DateTime?
  triggerCount    Int       @default(0)

  triggers AlertTrigger[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([game])
  @@index([isActive])
  @@index([cardName])
}

model AlertTrigger {
  id        String     @id @default(cuid())
  alertId   String
  alert     PriceAlert @relation(fields: [alertId], references: [id], onDelete: Cascade)
  listingId String
  listing   ListingP2P @relation(fields: [listingId], references: [id], onDelete: Cascade)

  matchedPrice     Float
  notificationSent Boolean @default(false)

  triggeredAt DateTime @default(now())

  @@index([alertId])
  @@index([listingId])
  @@index([triggeredAt])
}

// ============= EVENTS CALENDAR SYSTEM =============

enum EventType {
  TOURNAMENT
  MEETUP
  RELEASE_PARTY
  TRADE_NIGHT
  PREMIUM_EVENT
  OTHER
}

enum EventStatus {
  DRAFT
  PUBLISHED
  CANCELLED
  COMPLETED
}

model CommunityEvent {
  id          String    @id @default(cuid())
  title       String
  description String?   @db.Text
  type        EventType
  game        CardGame?

  // Organizer (can be User or Shop)
  organizerUserId String?
  organizerShopId String?

  // Event details
  date       DateTime
  endDate    DateTime? // For multi-day events
  time       String? // e.g., "14:00"
  location   String? // Address or "Online"
  isOnline   Boolean   @default(false)
  onlineLink String? // Zoom/Discord link

  // Capacity
  maxParticipants Int?
  entryFee        Float?

  // Premium features
  isPremiumOnly Boolean @default(false)
  requiredTier  String? // "PREMIUM", "PRO"

  // Community integration
  discussionTopicId String? // Auto-create topic for discussion

  status EventStatus @default(DRAFT)

  registrations EventRegistration[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([type])
  @@index([game])
  @@index([date])
  @@index([status])
  @@index([isPremiumOnly])
}

model EventRegistration {
  id      String         @id @default(cuid())
  eventId String
  event   CommunityEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)
  userId  String
  user    User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  status String @default("REGISTERED") // REGISTERED, WAITLIST, CANCELLED, ATTENDED

  // Premium priority tracking
  isPriorityRegistration Boolean @default(false)

  createdAt DateTime @default(now())

  @@unique([eventId, userId])
  @@index([eventId])
  @@index([userId])
  @@index([status])
}

// ============= CONTACT SUPPORT MESSAGES =============

enum ContactStatus {
  PENDING
  READ
  REPLIED
  CLOSED
}

model ContactMessage {
  id         String        @id @default(cuid())
  userId     String? // Can be null for anonymous users
  user       User?         @relation("ContactMessages", fields: [userId], references: [id], onDelete: SetNull)
  email      String // Email for reply
  name       String // Name of sender
  subject    String
  message    String        @db.Text
  status     ContactStatus @default(PENDING)
  adminReply String?       @db.Text
  repliedAt  DateTime?
  repliedBy  String? // Admin user ID who replied
  ipAddress  String? // For rate limiting anonymous users
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt

  @@index([userId])
  @@index([email])
  @@index([status])
  @@index([createdAt])
}

// ============= SISTEMA APPROVAZIONE MANUALE RILASCIO FONDI =============

enum PendingReleaseType {
  RELEASE_TO_SELLER // Rilascio fondi al venditore
  REFUND_FULL // Rimborso totale al buyer
  REFUND_PARTIAL // Rimborso parziale
  HUB_COMMISSION // Commissione Hub Provider
  WITHDRAWAL // Prelievo wallet
  INSURANCE_REFUND // Rimborso assicurativo
}

enum PendingReleaseStatus {
  PENDING // In attesa di approvazione
  APPROVED // Approvato e processato
  REJECTED // Rifiutato
  EXPIRED // Scaduto senza azione
}

model PendingRelease {
  id String @id @default(cuid())

  // Riferimenti
  orderId   String?
  order     SafeTradeTransaction? @relation("PendingReleases", fields: [orderId], references: [id], onDelete: SetNull)
  disputeId String?
  dispute   Dispute?              @relation("PendingReleaseDispute", fields: [disputeId], references: [id], onDelete: SetNull)

  // Dettagli rilascio
  type          PendingReleaseType
  amount        Float
  recipientId   String
  recipient     User               @relation("PendingReleaseRecipient", fields: [recipientId], references: [id], onDelete: Cascade)
  recipientType String // 'SELLER', 'BUYER', 'HUB'

  // Status
  status PendingReleaseStatus @default(PENDING)

  // Motivo/contesto
  reason      String?  @db.Text
  triggeredBy String? // 'DELIVERY_CONFIRMED', 'HUB_VERIFIED', 'DISPUTE_RESOLVED', 'WITHDRAWAL_REQUEST'
  triggeredAt DateTime @default(now())

  // Token conferma doppia (valido 5 minuti)
  confirmationToken String?   @unique
  tokenExpiresAt    DateTime?

  // Approvazione
  approvedById  String?
  approvedBy    User?     @relation("PendingReleaseApprover", fields: [approvedById], references: [id], onDelete: SetNull)
  approvedAt    DateTime?
  approvalNotes String?   @db.Text

  // Rifiuto
  rejectedById    String?
  rejectedBy      User?     @relation("PendingReleaseRejecter", fields: [rejectedById], references: [id], onDelete: SetNull)
  rejectedAt      DateTime?
  rejectionReason String?   @db.Text

  // Audit
  auditLog FinancialAuditLog? @relation("PendingReleaseAudit")

  createdAt DateTime  @default(now())
  expiresAt DateTime? // Opzionale: scadenza se non processato

  @@index([status])
  @@index([type])
  @@index([recipientId])
  @@index([orderId])
  @@index([createdAt])
}

// Log Audit per tutte le azioni finanziarie
model FinancialAuditLog {
  id String @id @default(cuid())

  // Tipo azione
  actionType String // 'RELEASE_APPROVED', 'RELEASE_REJECTED', 'REFUND_APPROVED', etc.

  // Riferimenti
  pendingReleaseId String?         @unique
  pendingRelease   PendingRelease? @relation("PendingReleaseAudit", fields: [pendingReleaseId], references: [id], onDelete: SetNull)
  orderId          String?

  // Dettagli finanziari
  amount      Float
  recipientId String?

  // Chi ha eseguito l'azione
  performedById   String
  performedBy     User   @relation("AuditPerformer", fields: [performedById], references: [id], onDelete: Cascade)
  performedByRole String // 'ADMIN', 'MODERATOR'

  // Sicurezza e tracciabilità
  ipAddress String?
  userAgent String? @db.Text

  // Timestamp doppia conferma
  firstClickAt   DateTime
  confirmClickAt DateTime

  notes String? @db.Text

  createdAt DateTime @default(now())

  @@index([actionType])
  @@index([performedById])
  @@index([createdAt])
  @@index([orderId])
}

// Notifiche per Admin/Moderator
enum AdminNotificationType {
  PENDING_RELEASE // Nuovo rilascio in attesa
  DISPUTE_OPENED // Nuova disputa aperta
  DISPUTE_ESCALATED // Dispute escalata
  DISPUTE_RESOLVED // Dispute risolta
  WITHDRAWAL_REQUEST // Richiesta prelievo
  HUB_VERIFICATION // Hub ha verificato pacco
  URGENT_ACTION // Azione urgente richiesta
  INSURANCE_CLAIM // Nuovo sinistro assicurativo
  VAULT_CASE_REQUEST // Richiesta teca Vault da merchant
  MERCHANT_APPLICATION // Nuova richiesta merchant application
  LISTING_PENDING // Listing richiede approvazione manuale
  ESCROW_PAYMENT_CONFIRMED // Pagamento Verified Escrow confermato da admin/escrow agent
  STRIPE_PAYMENT_AUTHORIZED // Pagamento Stripe autorizzato (webhook payment_intent.succeeded)
}

enum NotificationPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

model AdminNotification {
  id String @id @default(cuid())

  type          AdminNotificationType
  referenceType String // 'PENDING_RELEASE', 'DISPUTE', 'ORDER'
  referenceId   String

  title    String
  message  String               @db.Text
  priority NotificationPriority @default(NORMAL)

  // Targeting (quali ruoli devono vedere)
  targetRoles String[] @default(["ADMIN", "MODERATOR"])

  // Tracking lettura
  readByIds String[] @default([])

  // Azione presa
  actionedById String?
  actionedBy   User?     @relation("NotificationActioner", fields: [actionedById], references: [id], onDelete: SetNull)
  actionedAt   DateTime?

  createdAt DateTime @default(now())

  @@index([type])
  @@index([priority])
  @@index([createdAt])
}

// ============= SISTEMA DISPUTE =============

enum DisputeStatus {
  OPEN // Dispute aperta
  SELLER_RESPONSE // In attesa risposta seller
  IN_MEDIATION // In mediazione admin
  RESOLVED // Risolta
  ESCALATED // Escalation ad admin senior
  CLOSED // Chiusa
}

enum DisputeType {
  NOT_DELIVERED // Pacco non arrivato
  DAMAGED_CARDS // Carte danneggiate
  WRONG_CONTENT // Contenuto errato
  MISSING_ITEMS // Articoli mancanti
  CONDITION_MISMATCH // Condizione non conforme
  DELAY // Ritardo eccessivo
  OTHER // Altro
}

enum DisputeResolution {
  REFUND_FULL // Rimborso totale buyer
  REFUND_PARTIAL // Rimborso parziale
  REPLACEMENT // Sostituzione
  RETURN_REQUIRED // Reso richiesto
  REJECTED // Dispute rifiutata
  IN_FAVOR_BUYER // A favore buyer
  IN_FAVOR_SELLER // A favore seller
}

model Dispute {
  id            String               @id @default(cuid())
  transactionId String
  transaction   SafeTradeTransaction @relation("Disputes", fields: [transactionId], references: [id], onDelete: Cascade)

  // Dispute Details
  type        DisputeType
  status      DisputeStatus @default(OPEN)
  title       String
  description String        @db.Text
  openedById  String
  openedBy    User          @relation("DisputeOpener", fields: [openedById], references: [id], onDelete: Cascade)

  // Resolution
  resolution       DisputeResolution?
  resolutionNotes  String?            @db.Text
  resolutionAmount Float? // Importo rimborso se parziale
  resolvedById     String?
  resolvedAt       DateTime?

  // Mediation
  mediatorId        String?
  mediationNotes    String?   @db.Text
  mediationDeadline DateTime?

  // Evidence
  photos    String[] // Foto documentazione
  documents String[] // Documenti allegati

  // Timeline
  sellerResponseDeadline DateTime? // 48h per rispondere
  openedAt               DateTime  @default(now())
  updatedAt              DateTime  @updatedAt
  closedAt               DateTime?

  // Relations
  messages        DisputeMessage[]
  pendingReleases PendingRelease[] @relation("PendingReleaseDispute")

  @@index([transactionId])
  @@index([status])
  @@index([type])
  @@index([openedById])
}

model DisputeMessage {
  id         String   @id @default(cuid())
  disputeId  String
  dispute    Dispute  @relation(fields: [disputeId], references: [id], onDelete: Cascade)
  senderId   String
  sender     User     @relation("DisputeMessageSender", fields: [senderId], references: [id], onDelete: Cascade)
  content    String   @db.Text
  photos     String[] // Foto aggiuntive
  isInternal Boolean  @default(false) // Messaggio interno admin
  createdAt  DateTime @default(now())

  @@index([disputeId])
  @@index([senderId])
}

// ============= ASSICURAZIONE PACCHI =============

enum InsuranceStatus {
  NOT_INSURED // Nessuna assicurazione
  ACTIVE // Assicurazione attiva
  CLAIMED // Sinistro dichiarato
  SETTLED // Sinistro risolto
  EXPIRED // Scaduta
}

model PackageInsurance {
  id            String               @id @default(cuid())
  transactionId String               @unique
  transaction   SafeTradeTransaction @relation("PackageInsurance", fields: [transactionId], references: [id], onDelete: Cascade)

  // Insurance Details
  insuredValue  Float // Valore assicurato
  premiumAmount Float // Premio pagato
  coverageType  String          @default("STANDARD") // STANDARD, PREMIUM
  status        InsuranceStatus @default(ACTIVE)

  // Premium Calculation
  baseRate   Float @default(2.0) // Percentuale base (2%)
  riskFactor Float @default(1.0) // Fattore rischio (1.0-2.0)

  // Claim Details (se sinistro)
  claimAmount        Float? // Importo sinistro richiesto
  claimReason        String?   @db.Text
  claimPhotos        String[] // Foto documentazione sinistro
  claimSubmittedAt   DateTime?
  claimSettledAt     DateTime?
  claimSettledAmount Float?
  claimNotes         String?   @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([transactionId])
  @@index([status])
}

// ============= MULTI-PACKAGE SYSTEM =============

model Package {
  id            String               @id @default(cuid())
  transactionId String
  transaction   SafeTradeTransaction @relation("Packages", fields: [transactionId], references: [id], onDelete: Cascade)

  // Package Details
  packageNumber Int // Numero pacco nella transazione (1, 2, 3...)
  sellerId      String // Seller che ha inviato questo pacco
  seller        User   @relation("PackageSeller", fields: [sellerId], references: [id], onDelete: Cascade)

  // Tracking
  trackingNumber String? // Tracking pacco verso hub
  status         HubPackageStatus @default(PENDING)

  // Timestamps
  receivedAt  DateTime?
  verifiedAt  DateTime?
  shippedAt   DateTime?
  deliveredAt DateTime?

  // Verification
  verificationPhotos String[] // Foto verifica questo pacco
  verifiedById       String? // Hub provider ID

  // Value
  packageValue Float // Valore questo pacco

  // Consolidation
  isConsolidated       Boolean @default(false)
  consolidationGroupId String? // ID gruppo consolidazione

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([transactionId, packageNumber])
  @@index([transactionId])
  @@index([sellerId])
  @@index([status])
}

model PackageConsolidation {
  id            String               @id @default(cuid())
  transactionId String
  transaction   SafeTradeTransaction @relation("Consolidations", fields: [transactionId], references: [id], onDelete: Cascade)

  // Consolidation Details
  packageIds String[] // IDs dei pacchi consolidati
  totalValue Float // Valore totale consolidato

  // Shipping
  consolidatedTrackingNumber String? // Tracking pacco consolidato
  consolidatedAt             DateTime?
  shippedAt                  DateTime?

  // Cost Savings
  individualShippingCost   Float // Costo spedizioni separate
  consolidatedShippingCost Float // Costo spedizione consolidata
  savingsAmount            Float // Risparmio

  status String @default("PENDING") // PENDING, READY, SHIPPED, DELIVERED

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([transactionId])
}

// ============= SAFETRADE VAULT SYSTEM =============

enum VaultDepositStatus {
  CREATED // Deposito creato dall'utente
  RECEIVED // Ricevuto all'hub
  IN_REVIEW // In revisione
  ACCEPTED // Tutti gli item accettati
  PARTIAL // Alcuni item accettati, altri rifiutati
  REJECTED // Tutti gli item rifiutati
  DISTRIBUTED // Item assegnati ai negozi
  CLOSED // Deposito chiuso
}

enum VaultItemStatus {
  PENDING_REVIEW // In attesa di review hub
  ACCEPTED // Accettato dall'hub
  REJECTED // Rifiutato dall'hub
  ASSIGNED_TO_SHOP // Assegnato a negozio
  IN_CASE // Posizionato in teca
  LISTED_ONLINE // Listato online
  RESERVED // Riservato (ordine online pagato)
  SOLD // Venduto (fisico o online)
  RETURNED // Restituito al proprietario
}

enum VaultCaseStatus {
  IN_HUB // Teca in hub
  IN_TRANSIT // Teca in transito verso negozio
  IN_SHOP_ACTIVE // Teca attiva in negozio
  RETIRED // Teca ritirata
}

enum VaultCaseSlotStatus {
  FREE // Slot libero
  OCCUPIED // Slot occupato da item
}

enum VaultOrderStatus {
  PENDING_PAYMENT // In attesa pagamento
  PAID // Pagato
  FULFILLING // Merchant sta preparando spedizione
  SHIPPED // Spedito
  DELIVERED // Consegnato
  DISPUTED // Disputa aperta
  REFUNDED // Rimborsato
  CANCELLED // Cancellato
}

enum VaultFulfillmentStatus {
  LABEL_CREATED // Etichetta creata
  PACKED // Imballato
  SHIPPED // Spedito
  DELIVERED // Consegnato
  LOST // Perso
  RETURNED // Restituito
}

enum VaultSplitStatus {
  PENDING // Split creato ma non ancora eleggibile
  ELIGIBLE // Eleggibile per payout (dopo hold period)
  IN_PAYOUT // Incluso in batch payout
  PAID // Pagato
  REVERSED // Reversato (dispute/refund)
}

enum VaultPayoutBatchStatus {
  CREATED // Batch creato
  PROCESSING // In elaborazione
  PAID // Pagato
}

enum VaultPayoutLineStatus {
  PENDING // In attesa
  PAID // Pagato
}

enum VaultSplitSourceType {
  ORDER // Da ordine online
  SALE // Da vendita fisica
}

enum VaultPayoutPayeeType {
  USER // Proprietario carta
  SHOP // Negoziante
  PLATFORM // SafeTrade
}

// Deposito hub - utente invia carte all'hub
model VaultDeposit {
  id              String @id @default(cuid())
  depositorUserId String
  depositor       User   @relation(fields: [depositorUserId], references: [id], onDelete: Cascade)

  trackingIn String? // Tracking pacco verso hub
  status     VaultDepositStatus @default(CREATED)
  notes      String?            @db.Text

  // Timestamps
  receivedAt    DateTime?
  reviewedAt    DateTime?
  distributedAt DateTime?
  closedAt      DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  items     VaultItem[]
  auditLogs VaultAuditLog[]

  @@index([depositorUserId])
  @@index([status])
  @@index([createdAt])
}

// Item nel deposito - singola carta
model VaultItem {
  id          String       @id @default(cuid())
  ownerUserId String // Proprietario originale della carta
  owner       User         @relation("VaultItemOwner", fields: [ownerUserId], references: [id], onDelete: Cascade)
  depositId   String
  deposit     VaultDeposit @relation(fields: [depositId], references: [id], onDelete: Cascade)

  // Dettagli carta
  game              CardGame
  name              String // Nome carta
  set               String? // Set
  conditionDeclared CardCondition // Condizione dichiarata
  conditionVerified CardCondition? // Condizione verificata hub
  priceFinal        Float? // Prezzo finale stabilito hub

  status VaultItemStatus @default(PENDING_REVIEW)

  // Location corrente
  shopIdCurrent String? // Negoziante corrente
  shop          Shop?          @relation("VaultItemShop", fields: [shopIdCurrent], references: [id], onDelete: SetNull)
  caseId        String? // Teca corrente
  case          VaultCase?     @relation(fields: [caseId], references: [id], onDelete: SetNull)
  slotId        String?        @unique // Slot corrente (one-to-one)
  slot          VaultCaseSlot? @relation(fields: [slotId], references: [id], onDelete: SetNull)

  photos String[] // Foto item

  // SafeVault Integration - Collegamento a Listing
  listingId String? @unique // Collegamento a ListingP2P (se creato da listing)
  listing   ListingP2P? @relation("ListingVaultItem")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  sale      VaultSale?
  order     VaultOrder?
  splits    VaultSplit[]
  auditLogs VaultAuditLog[]

  @@index([ownerUserId])
  @@index([depositId])
  @@index([status])
  @@index([shopIdCurrent])
  @@index([caseId])
  @@index([slotId])
  @@index([game])
  @@index([listingId])
}

// Teca fisica brandizzata
model VaultCase {
  id               String  @id @default(cuid())
  shopId           String? // Negoziante corrente (null se in hub)
  shop             Shop?   @relation("VaultCaseShop", fields: [shopId], references: [id], onDelete: SetNull)
  authorizedShopId String? @unique // Shop autorizzato (ha pagato) - relazione one-to-one
  authorizedShop   Shop?   @relation("ShopVaultCase", fields: [authorizedShopId], references: [id], onDelete: SetNull)

  status VaultCaseStatus @default(IN_HUB)
  label  String? // Etichetta/numero teca

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  slots VaultCaseSlot[]
  items VaultItem[]

  @@index([shopId])
  @@index([status])
}

// Slot nella teca (30 slot fissi S01..S30)
model VaultCaseSlot {
  id     String    @id @default(cuid())
  caseId String
  case   VaultCase @relation(fields: [caseId], references: [id], onDelete: Cascade)

  slotCode String // S01, S02, ..., S30
  qrToken  String              @unique // Token QR univoco per scansione
  status   VaultCaseSlotStatus @default(FREE)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  item VaultItem?

  @@unique([caseId, slotCode])
  @@index([caseId])
  @@index([qrToken])
  @@index([status])
}

// Vendita fisica in negozio
model VaultSale {
  id     String    @id @default(cuid())
  itemId String    @unique
  item   VaultItem @relation(fields: [itemId], references: [id], onDelete: Cascade)
  shopId String
  shop   Shop      @relation(fields: [shopId], references: [id], onDelete: Cascade)

  soldPrice               Float
  proofImage              String? // Foto prova vendita
  soldAt                  DateTime @default(now())
  createdByMerchantUserId String // Merchant che ha registrato vendita

  createdAt DateTime @default(now())

  @@index([itemId])
  @@index([shopId])
  @@index([soldAt])
}

// Ordine online
model VaultOrder {
  id                String    @id @default(cuid())
  itemId            String    @unique
  item              VaultItem @relation(fields: [itemId], references: [id], onDelete: Cascade)
  buyerUserId       String
  buyer             User      @relation(fields: [buyerUserId], references: [id], onDelete: Cascade)
  shopIdFulfillment String // Negoziante che evaderà ordine
  shop              Shop      @relation(fields: [shopIdFulfillment], references: [id], onDelete: Cascade)

  status VaultOrderStatus @default(PENDING_PAYMENT)

  // Shipping
  shippingAddress Json // Indirizzo spedizione
  totals          Json // { subtotal, shipping, tax, total }

  // Relations
  fulfillment VaultFulfillment?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([itemId])
  @@index([buyerUserId])
  @@index([shopIdFulfillment])
  @@index([status])
  @@index([createdAt])
}

// Fulfillment ordine online (spedizione)
model VaultFulfillment {
  id      String     @id @default(cuid())
  orderId String     @unique
  order   VaultOrder @relation(fields: [orderId], references: [id], onDelete: Cascade)

  carrier      String? // Corriere
  trackingCode String? // Codice tracking
  status       VaultFulfillmentStatus @default(LABEL_CREATED)

  updatedAt DateTime @updatedAt

  @@index([orderId])
  @@index([trackingCode])
  @@index([status])
}

// Split ricavi (70% owner, 20% merchant, 10% platform)
model VaultSplit {
  id         String               @id @default(cuid())
  sourceType VaultSplitSourceType // ORDER o SALE
  sourceId   String // ID ordine o vendita
  itemId     String
  item       VaultItem            @relation(fields: [itemId], references: [id], onDelete: Cascade)

  ownerUserId String
  owner       User   @relation("VaultSplitOwner", fields: [ownerUserId], references: [id], onDelete: Cascade)
  shopId      String
  shop        Shop   @relation("VaultSplitMerchant", fields: [shopId], references: [id], onDelete: Cascade)

  grossAmount    Float // Importo lordo vendita
  ownerAmount    Float // 70% al proprietario
  merchantAmount Float // 20% al negoziante
  platformAmount Float // 10% a SafeTrade

  status     VaultSplitStatus @default(PENDING)
  eligibleAt DateTime? // Data eleggibilità (dopo hold period)

  // Relations
  payoutLine VaultPayoutLine?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([itemId])
  @@index([ownerUserId])
  @@index([shopId])
  @@index([status])
  @@index([sourceType, sourceId])
  @@index([eligibleAt])
}

// Batch payout (raggruppamento per statement)
model VaultPayoutBatch {
  id     String                 @id @default(cuid())
  type   VaultPayoutPayeeType // OWNER, MERCHANT, o PLATFORM
  status VaultPayoutBatchStatus @default(CREATED)

  periodStart DateTime?
  periodEnd   DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  lines VaultPayoutLine[]

  @@index([type])
  @@index([status])
  @@index([createdAt])
}

// Linea payout nel batch
model VaultPayoutLine {
  id      String           @id @default(cuid())
  batchId String
  batch   VaultPayoutBatch @relation(fields: [batchId], references: [id], onDelete: Cascade)
  splitId String?          @unique // Riferimento split (se da split)
  split   VaultSplit?      @relation(fields: [splitId], references: [id], onDelete: SetNull)

  payeeType VaultPayoutPayeeType // USER, SHOP, PLATFORM
  payeeId   String // ID proprietario/negoziante/platform
  amount    Float

  status VaultPayoutLineStatus @default(PENDING)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([batchId])
  @@index([payeeType, payeeId])
  @@index([status])
}

// Audit log per operazioni Vault
model VaultAuditLog {
  id String @id @default(cuid())

  // Riferimenti
  depositId String?
  deposit   VaultDeposit? @relation(fields: [depositId], references: [id], onDelete: SetNull)
  itemId    String?
  item      VaultItem?    @relation(fields: [itemId], references: [id], onDelete: SetNull)
  orderId   String?
  saleId    String?
  caseId    String?
  slotId    String?

  // Azione
  actionType    String // 'DEPOSIT_CREATED', 'ITEM_ACCEPTED', 'ITEM_ASSIGNED', 'SLOT_OCCUPIED', etc.
  performedById String
  performedBy   User   @relation(fields: [performedById], references: [id], onDelete: Cascade)

  // Dettagli
  oldValue Json? // Valore precedente (per state changes)
  newValue Json? // Nuovo valore
  notes    String? @db.Text

  createdAt DateTime @default(now())

  @@index([depositId])
  @@index([itemId])
  @@index([orderId])
  @@index([actionType])
  @@index([performedById])
  @@index([createdAt])
}

// Richieste teche Vault da parte dei merchant
enum VaultCaseRequestStatus {
  PENDING // In attesa di approvazione admin
  APPROVED // Approvata, in attesa di pagamento
  REJECTED // Rifiutata
  PAID // Pagata, teca da creare
  COMPLETED // Teca creata e assegnata
  CANCELLED // Cancellata dal merchant
}

model VaultCaseRequest {
  id              String @id @default(cuid())
  shopId          String
  shop            Shop   @relation("VaultCaseRequest", fields: [shopId], references: [id], onDelete: Cascade)
  requestedBy     String // User ID del merchant
  requestedByUser User   @relation("VaultCaseRequestUser", fields: [requestedBy], references: [id], onDelete: Cascade)

  status     VaultCaseRequestStatus @default(PENDING)
  notes      String? // Note del merchant
  adminNotes String? // Note dell'admin

  // Payment tracking (per futuro Stripe)
  paymentIntentId String? // Stripe Payment Intent ID
  paymentStatus   String? // PENDING, PAID, FAILED

  // Timestamps
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  approvedAt  DateTime?
  rejectedAt  DateTime?
  paidAt      DateTime?
  completedAt DateTime?

  @@index([shopId])
  @@index([requestedBy])
  @@index([status])
  @@index([createdAt])
}

// Security Audit Log - Logging tentativi accesso non autorizzati
model SecurityAuditLog {
  id String @id @default(cuid())

  // Tipo di evento
  eventType String // 'QR_SCAN_UNAUTHORIZED', 'PAYMENT_ACCESS_UNAUTHORIZED', 'VAULT_ACCESS_UNAUTHORIZED', etc.

  // Utente che ha tentato l'accesso
  attemptedById String?
  attemptedBy   User?   @relation("SecurityAuditAttemptedBy", fields: [attemptedById], references: [id], onDelete: SetNull)

  // Dettagli tentativo
  endpoint     String // Endpoint chiamato (es. '/api/merchant/verify/scan')
  method       String // HTTP method (GET, POST, etc.)
  resourceId   String? // ID della risorsa (es. sessionId, qrCode, paymentId)
  resourceType String? // Tipo risorsa (es. 'ESCROW_SESSION', 'PAYMENT', 'VAULT_SLOT')

  // Informazioni richiesta
  ipAddress   String?
  userAgent   String? @db.Text
  requestBody Json? // Body della richiesta (sanitizzato)

  // Risultato
  wasBlocked Boolean @default(true) // Se l'accesso è stato bloccato
  reason     String? // Motivo del blocco (es. 'Merchant not authorized', 'QR code expired')

  // Metadata
  // Severity: 'LOW', 'MEDIUM', 'HIGH', 'CRITICAL'
  severity String @default("MEDIUM")
  metadata Json? // Dati aggiuntivi

  createdAt DateTime @default(now())

  @@index([eventType])
  @@index([attemptedById])
  @@index([endpoint])
  @@index([resourceId])
  @@index([createdAt])
  @@index([severity])
}

// ============= SHIPPING LABEL SYSTEM (SHIPPO) =============

enum ShippingLabelStatus {
  CREATED       // Etichetta generata, non ancora stampata
  PRINTED       // Etichetta stampata dal seller
  SHIPPED       // Pacco spedito dal seller
  IN_TRANSIT    // In transito verso hub
  DELIVERED     // Consegnato all'hub
  CANCELLED     // Etichetta cancellata
}

model ShippingLabel {
  id            String   @id @default(cuid())
  transactionId String   @unique
  transaction   SafeTradeTransaction @relation("TransactionShippingLabel", fields: [transactionId], references: [id], onDelete: Cascade)
  
  // Provider info
  courier       String   // "dhl_express", "ups", "fedex", etc.
  provider      String   @default("SHIPPO") // "SHIPPO", "SHIPPYPRO", etc.
  
  // Shippo-specific data
  shippoTransactionId String? // ID transazione Shippo
  shippoRateId        String? // ID tariffa Shippo
  shippoTrackingNumber String? // Tracking number generato da Shippo
  
  // Label data
  labelUrl      String?  // URL PDF etichetta generata (da Shippo)
  labelPdfBase64 String? @db.Text // Base64 PDF etichetta (per download)
  
  // Shipping details
  weight        Float    // Peso pacco (kg)
  weightUnit    String   @default("kg") // "kg" o "lb"
  dimensions    Json?    // {length, width, height} in cm
  
  // Addresses (JSON per flessibilità)
  fromAddress   Json     // Indirizzo mittente (seller/hub)
  toAddress     Json     // Indirizzo destinatario (hub/buyer)
  
  // Service type
  service       String?  // "STANDARD", "EXPRESS", etc.
  
  // Costs
  costAmount    Float    // Costo reale corriere (in EUR)
  chargedAmount Float    // Importo addebitato al buyer/seller (in EUR)
  marginAmount  Float    @default(0) // Margine guadagnato (chargedAmount - costAmount)
  
  // Status
  status        ShippingLabelStatus @default(CREATED)
  generatedAt   DateTime @default(now())
  printedAt     DateTime?
  shippedAt     DateTime?
  deliveredAt   DateTime?
  cancelledAt   DateTime?
  
  // Metadata
  notes         String?  @db.Text
  metadata      Json?    // Dati aggiuntivi
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([transactionId])
  @@index([status])
  @@index([courier])
  @@index([generatedAt])
}

// ============= MERCHANT LEDGER & INVOICING =============
// Tracciamento commissioni merchant per ogni trade completato.
// Per CASH: il merchant ha già incassato tutto fisicamente, la piattaforma deve fatturare la sua quota.
// Per ONLINE: la piattaforma deduce automaticamente la sua quota.

enum MerchantInvoiceStatus {
  DRAFT // In preparazione (non ancora inviata)
  ISSUED // Emessa e inviata al merchant
  PAID // Merchant ha pagato la quota piattaforma
  OVERDUE // Scaduta e non pagata
  CANCELLED // Annullata
}

// Singola voce di registro per ogni trade completato in un negozio
model MerchantLedgerEntry {
  id              String               @id @default(cuid())
  shopId          String
  shop            Shop                 @relation(fields: [shopId], references: [id], onDelete: Cascade)
  transactionId   String
  transaction     SafeTradeTransaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)

  // Dettagli trade
  tradeAmount     Float // Importo totale del trade (es. €100)
  feePercentage   Float // Percentuale fee applicata (es. 5.0 = 5%)
  feeAmount       Float // Fee totale calcolata (es. €5)
  feePaidBy       String // "SELLER", "BUYER", "SPLIT"

  // Split della fee tra merchant e piattaforma
  platformFeeSharePercent Float // % della fee che spetta alla piattaforma (es. 10.0)
  merchantCut     Float // Quota merchant (es. €4.50 = 90% di €5)
  platformCut     Float // Quota piattaforma (es. €0.50 = 10% di €5)

  // Metodo pagamento: determina come la piattaforma incassa la sua quota
  paymentMethod   String // "CASH" o "ONLINE"
  // CASH: merchant ha già incassato tutto → piattaforma deve fatturare platformCut
  // ONLINE: piattaforma deduce automaticamente platformCut dal pagamento Stripe

  // Stato incasso piattaforma
  platformCollected Boolean @default(false) // La piattaforma ha incassato la sua quota?
  // Per ONLINE: true subito (auto-dedotto)
  // Per CASH: true quando il merchant paga la fattura mensile

  // Riferimento fattura
  invoiceId       String?
  invoice         MerchantInvoice? @relation(fields: [invoiceId], references: [id], onDelete: SetNull)

  createdAt       DateTime @default(now())

  @@index([shopId])
  @@index([transactionId])
  @@index([invoiceId])
  @@index([paymentMethod])
  @@index([platformCollected])
  @@index([createdAt])
}

// Fattura mensile per un merchant - aggrega tutte le voci del periodo
model MerchantInvoice {
  id              String   @id @default(cuid())
  invoiceNumber   String   @unique // es. "INV-2026-02-SHOP001"
  shopId          String
  shop            Shop     @relation(fields: [shopId], references: [id], onDelete: Cascade)

  // Periodo di riferimento
  periodStart     DateTime // Primo giorno del mese
  periodEnd       DateTime // Ultimo giorno del mese

  // Riepilogo trades
  totalTrades       Int   // Totale trades nel periodo
  cashTrades        Int   // Trades pagati in contanti
  onlineTrades      Int   // Trades pagati online (Stripe)

  // Volumi e fee
  totalTradeVolume  Float // Somma di tutti i tradeAmount del periodo
  totalFees         Float // Somma di tutte le fee del periodo
  totalMerchantCut  Float // Totale quota merchant
  totalPlatformCut  Float // Totale quota piattaforma

  // Breakdown cash vs online
  cashFees          Float // Fee totali da trades cash
  cashMerchantCut   Float // Quota merchant da trades cash
  cashPlatformCut   Float // Quota piattaforma da trades cash (= DEBITO del merchant)
  onlineFees        Float // Fee totali da trades online
  onlineMerchantCut Float // Quota merchant da trades online
  onlinePlatformCut Float // Quota piattaforma da trades online (auto-dedotta)

  // Importo dovuto dal merchant alla piattaforma
  // = cashPlatformCut (perché il merchant ha già incassato la quota piattaforma fisicamente)
  amountDue         Float

  // Status
  status            MerchantInvoiceStatus @default(DRAFT)

  // Date operative
  issuedAt          DateTime? // Quando la fattura è stata emessa
  dueDate           DateTime? // Scadenza pagamento (es. 15 del mese successivo)
  paidAt            DateTime? // Quando il merchant ha pagato

  // Dettagli pagamento del merchant verso la piattaforma
  paymentMethod     String?  // Come il merchant ha pagato (es. "BANK_TRANSFER", "STRIPE")
  paymentReference  String?  // Riferimento pagamento (es. CRO bonifico)

  // Note admin
  notes             String?  @db.Text

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Voci di dettaglio
  entries           MerchantLedgerEntry[]

  @@unique([shopId, periodStart, periodEnd]) // Una sola fattura per shop per periodo
  @@index([shopId])
  @@index([status])
  @@index([periodStart, periodEnd])
  @@index([invoiceNumber])
  @@index([dueDate])
}

// Autorizzazione Escrow Agent - Solo l'admin può autorizzare
model EscrowAgentAuthorization {
  id              String   @id @default(cuid())
  userId          String   @unique // L'utente autorizzato come escrow agent
  user            User     @relation("EscrowAgentAuth", fields: [userId], references: [id], onDelete: Cascade)
  authorizedById  String   // L'admin che ha autorizzato
  authorizedBy    User     @relation("EscrowAgentAuthorizer", fields: [authorizedById], references: [id], onDelete: Cascade)

  isActive        Boolean  @default(true) // L'admin può revocare l'autorizzazione
  notes           String?  @db.Text // Motivo autorizzazione

  authorizedAt    DateTime @default(now())
  revokedAt       DateTime? // Se revocato

  @@index([userId])
  @@index([isActive])
}
