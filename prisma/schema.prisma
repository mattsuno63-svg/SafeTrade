// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

enum UserRole {
  USER
  MERCHANT
  MODERATOR  // Nuovo ruolo: può approvare rilascio fondi e gestire dispute, ma meno controllo di ADMIN
  ADMIN
}

enum ListingType {
  SALE
  TRADE
  BOTH
}

enum CardCondition {
  MINT
  NEAR_MINT
  EXCELLENT
  GOOD
  PLAYED
  POOR
}

enum ProposalStatus {
  PENDING
  ACCEPTED
  REJECTED
  CANCELLED
}

enum SafeTradeStatus {
  PENDING
  CONFIRMED
  COMPLETED
  CANCELLED
}

enum HubPackageStatus {
  PENDING // Package not yet sent
  IN_TRANSIT // Package sent to hub
  RECEIVED // Package received at hub
  VERIFIED // Contents verified
  SHIPPED // Package shipped to buyer
  DELIVERED // Package delivered to buyer
  RETURNED // Package returned to seller
}

enum CardGame {
  POKEMON
  MAGIC
  YUGIOH
  ONEPIECE
  DIGIMON
  OTHER
}

model User {
  id              String   @id @default(cuid())
  email           String   @unique
  passwordHash    String
  name            String?
  avatar          String?
  role            UserRole @default(USER)
  city            String? // User's city for geographic filtering
  province        String? // Province/region
  bio             String? // User's passion description (Onboarding)
  preferredShopId String? // Preferred SafeTrade store
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  listings                 ListingP2P[]
  proposalsSent            Proposal[]               @relation("Proposer")
  proposalsReceived        Proposal[]               @relation("Receiver")
  safeTradeTransactionsAsA SafeTradeTransaction[]   @relation("UserA")
  safeTradeTransactionsAsB SafeTradeTransaction[]   @relation("UserB")
  shop                     Shop?
  notifications            Notification[]
  tournamentRegistrations  TournamentRegistration[]
  messagesSent             Message[]                @relation("Sender")
  messagesReceived         Message[]                @relation("Receiver")
  conversationsAsUserA     Conversation[]           @relation("ConversationUserA")
  conversationsAsUserB     Conversation[]           @relation("ConversationUserB")
  merchantApplication      MerchantApplication?

  // Escrow relations
  escrowSessionsAsBuyer    EscrowSession[]   @relation("EscrowBuyer")
  escrowSessionsAsSeller   EscrowSession[]   @relation("EscrowSeller")
  escrowSessionsAsMerchant EscrowSession[]   @relation("EscrowMerchant")
  escrowMessagesSent       EscrowMessage[]   @relation("EscrowMessageSender")
  escrowWallet             EscrowWallet?     @relation("EscrowWallet")
  escrowHub                EscrowHub?        @relation("EscrowHubProvider")
  escrowHubReviews         EscrowHubReview[] @relation("EscrowHubReviewer")

  // Community Relations
  posts    Post[]
  comments Comment[]
  badges   UserBadge[]

  // Premium & Subscription
  subscription       UserSubscription?
  karma              UserKarma?
  priceAlerts        PriceAlert[]
  eventRegistrations EventRegistration[]

  // Contact Support
  contactMessages ContactMessage[] @relation("ContactMessages")

  // Dispute relations
  disputesOpened    Dispute[]        @relation("DisputeOpener")
  disputeMessages   DisputeMessage[] @relation("DisputeMessageSender")
  packages          Package[]        @relation("PackageSeller")

  // Approvazione Manuale Rilascio Fondi
  pendingReleasesAsRecipient PendingRelease[]    @relation("PendingReleaseRecipient")
  pendingReleasesApproved    PendingRelease[]    @relation("PendingReleaseApprover")
  pendingReleasesRejected    PendingRelease[]    @relation("PendingReleaseRejecter")
  financialAuditLogs         FinancialAuditLog[] @relation("AuditPerformer")
  adminNotificationsActioned AdminNotification[] @relation("NotificationActioner")

  @@index([email])
  @@index([role])
  @@index([city])
}

model Shop {
  id          String   @id @default(cuid())
  name        String
  slug        String?  @unique // URL-friendly identifier for subdomain (e.g., "nomenegozio")
  description String?
  logo        String?
  coverImage  String?
  images      String[] // Array of additional shop images for gallery
  address     String?
  city        String?
  postalCode  String?
  phone       String?
  email       String? // Shop email
  website     String? // Shop website
  rating      Float    @default(0)
  ratingCount Int      @default(0)
  merchantId  String   @unique
  merchant    User     @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  isApproved  Boolean  @default(false) // Manual approval required

  // Opening hours (JSON string: {"monday": {"open": "09:00", "close": "18:00", "closed": false}, ...})
  openingHours String?

  // Social media links
  facebookUrl  String?
  instagramUrl String?
  twitterUrl   String?
  youtubeUrl   String?
  tiktokUrl    String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  products      Product[]
  transactions  SafeTradeTransaction[]
  importBatches ImportBatch[]
  tournaments   Tournament[]
  apiKey        String?                @unique // For Chrome extension
  // Note: Full-text index will be created manually via SQL after db:push
  promotions    Promotion[]

  @@index([merchantId])
  @@index([name])
  @@index([slug])
  @@index([city])
  @@index([isApproved])
}

// ============= ESCROW HUB (PERSONAL ESCROW SERVICE) =============

model EscrowHub {
  id         String @id @default(cuid())
  providerId String @unique // User who provides escrow service
  provider   User   @relation("EscrowHubProvider", fields: [providerId], references: [id], onDelete: Cascade)

  // Hub Information
  name        String // Hub name (e.g., "Mario's Escrow Hub")
  description String? // Description of services

  // Address (home address for package receiving)
  address    String
  city       String
  province   String?
  postalCode String?
  country    String  @default("IT")

  // Contact
  phone String?
  email String? // Contact email

  // Hub Status
  isActive   Boolean @default(true)
  isApproved Boolean @default(false) // Manual approval required
  isVerified Boolean @default(false) // Identity verified by admin

  // Ratings & Stats
  rating                Float @default(0) // Average rating (0-5)
  ratingCount           Int   @default(0) // Number of ratings
  transactionsCompleted Int   @default(0) // Total transactions completed

  // Service Settings
  serviceFee        Float    @default(5.0) // Service fee percentage (default 5%)
  maxPackageValue   Float? // Maximum package value accepted (null = no limit)
  acceptedCountries String[] // Countries from which packages are accepted (empty = all)

  // Availability
  isAvailable Boolean @default(true) // Currently accepting new packages

  // Admin Review
  reviewNotes String? // Admin review notes
  reviewedAt  DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  transactions SafeTradeTransaction[]
  reviews      EscrowHubReview[]

  @@index([providerId])
  @@index([city])
  @@index([isActive])
  @@index([isApproved])
  @@index([isAvailable])
  @@index([rating])
}

// Hub Reviews & Ratings
model EscrowHubReview {
  id            String    @id @default(cuid())
  hubId         String
  hub           EscrowHub @relation(fields: [hubId], references: [id], onDelete: Cascade)
  reviewerId    String // User who left review
  reviewer      User      @relation("EscrowHubReviewer", fields: [reviewerId], references: [id], onDelete: Cascade)
  transactionId String? // Related transaction (optional)

  rating  Int // 1-5 stars
  comment String?  @db.Text
  pros    String[] // Positive aspects
  cons    String[] // Negative aspects

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([hubId, reviewerId, transactionId])
  @@index([hubId])
  @@index([reviewerId])
  @@index([rating])
  @@index([createdAt])
}

model Product {
  id          String        @id @default(cuid())
  title       String
  description String?
  price       Float
  condition   CardCondition
  game        CardGame
  set         String? // Set name
  cardNumber  String? // e.g., "25/102"
  rarity      String? // Common, Rare, Ultra Rare, etc.
  language    String        @default("IT")
  images      String[] // Array of image URLs (Supabase Storage)
  isActive    Boolean       @default(true)
  stock       Int           @default(1)
  shopId      String
  shop        Shop          @relation(fields: [shopId], references: [id], onDelete: Cascade)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  // Note: Full-text and trigram indexes will be created manually via SQL after db:push

  @@index([shopId])
  @@index([game])
  @@index([isActive])
  @@index([price])
}

enum ListingVisibility {
  EARLY_ACCESS // Solo Premium per 24h
  PUBLIC // Tutti possono vedere
}

model ListingP2P {
  id            String        @id @default(cuid())
  title         String
  description   String?
  type          ListingType
  price         Float? // If sale or both
  condition     CardCondition
  game          CardGame
  set           String? // Set name
  cardNumber    String? // e.g., "25/102"
  rarity        String?
  language      String        @default("IT")
  images        String[] // Array of image URLs (Cloudinary)
  wants         String? // What they want in trade
  isActive      Boolean       @default(true)
  isSold        Boolean       @default(false) // Marcato come venduto quando transazione completata
  isApproved    Boolean       @default(false) // Manual approval required by admin
  approvalNotes String? // Admin notes for approval/rejection
  userId        String
  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  // Early Access System (Premium Feature)
  visibility     ListingVisibility @default(PUBLIC)
  earlyAccessEnd DateTime? // Timestamp fine early access (24h dopo creazione)

  proposals        Proposal[]
  featuredListings FeaturedListing[]
  alertTriggers    AlertTrigger[]
  // Note: Full-text and trigram indexes will be created manually via SQL after db:push

  @@index([userId])
  @@index([game])
  @@index([type])
  @@index([isActive])
  @@index([isSold])
  @@index([isApproved])
  @@index([price])
  @@index([createdAt])
  @@index([visibility])
  @@index([earlyAccessEnd])
}

model Proposal {
  id         String         @id @default(cuid())
  listingId  String
  listing    ListingP2P     @relation(fields: [listingId], references: [id], onDelete: Cascade)
  proposerId String
  proposer   User           @relation("Proposer", fields: [proposerId], references: [id], onDelete: Cascade)
  receiverId String
  receiver   User           @relation("Receiver", fields: [receiverId], references: [id], onDelete: Cascade)
  type       ListingType // SALE or TRADE
  offerPrice Float? // Counter-offer if sale
  tradeItems String? // Description of items offered in trade
  message    String? // Optional message from proposer
  feePaidBy  FeePaidBy      @default(SELLER) // Chi paga la commissione SafeTrade
  status     ProposalStatus @default(PENDING)
  createdAt  DateTime       @default(now())
  updatedAt  DateTime       @updatedAt

  transaction SafeTradeTransaction?

  @@index([listingId])
  @@index([proposerId])
  @@index([receiverId])
  @@index([status])
  @@index([createdAt])
}

enum PriorityTier {
  STANDARD // Free users
  PRIORITY // Premium users
  FAST_TRACK // PRO users
}

model SafeTradeTransaction {
  id         String    @id @default(cuid())
  proposalId String?   @unique
  proposal   Proposal? @relation(fields: [proposalId], references: [id], onDelete: SetNull)
  userAId    String
  userA      User      @relation("UserA", fields: [userAId], references: [id], onDelete: Cascade)
  userBId    String
  userB      User      @relation("UserB", fields: [userBId], references: [id], onDelete: Cascade)

  // Support for both Shop-based and Hub-based escrow
  shopId String? // Optional - for shop-based escrow
  shop   Shop?      @relation(fields: [shopId], references: [id], onDelete: Restrict)
  hubId  String? // Optional - for hub-based escrow
  hub    EscrowHub? @relation(fields: [hubId], references: [id], onDelete: Restrict)

  scheduledDate    DateTime?
  scheduledTime    String? // Time slot (e.g., "10:00-11:00")
  status           SafeTradeStatus @default(PENDING)
  notes            String? // Notes from shop/hub or users
  verificationCode String? // Code for verification at store/hub
  completedAt      DateTime? // When transaction was completed
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt

  // Priority Queue System
  priorityTier PriorityTier @default(STANDARD)
  priorityPaid Boolean      @default(false) // Se ha pagato per priority (pay-per-use)

  // Hub Package Tracking (only for hub-based transactions)
  packageStatus        HubPackageStatus? // Status of package in hub
  trackingNumber       String? // Shipping tracking number (to hub)
  returnTrackingNumber String? // Return tracking number (to buyer)
  packageReceivedAt    DateTime? // When package received at hub
  packageVerifiedAt    DateTime? // When package verified at hub
  packageShippedAt     DateTime? // When package shipped to buyer
  packageDeliveredAt   DateTime? // When package delivered to buyer
  verificationPhotos   String[] // Photos of package contents for verification

  // Relations
  escrowSession   EscrowSession?
  escrowPayment   EscrowPayment?
  pendingReleases PendingRelease[] @relation("PendingReleases")

  // Insurance, Disputes, Packages
  insurance      PackageInsurance?       @relation("PackageInsurance")
  disputes       Dispute[]               @relation("Disputes")
  packages       Package[]               @relation("Packages")
  consolidations PackageConsolidation[]  @relation("Consolidations")

  @@index([userAId])
  @@index([userBId])
  @@index([shopId])
  @@index([hubId])
  @@index([status])
  @@index([scheduledDate])
  @@index([verificationCode])
  @@index([priorityTier])
  @@index([packageStatus])
}

model Notification {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  type      String // "proposal_received", "proposal_accepted", "transaction_confirmed", etc.
  title     String
  message   String
  link      String? // URL to related page
  data      Json? // Generic data field for structured info
  read      Boolean  @default(false)
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([read])
  @@index([createdAt])
}

model ImportBatch {
  id         String   @id @default(cuid())
  shopId     String
  shop       Shop     @relation(fields: [shopId], references: [id], onDelete: Cascade)
  source     String // "vinted", "cardmarket", "manual"
  status     String // "pending", "processing", "completed", "failed"
  itemsCount Int      @default(0)
  itemsData  Json? // Raw data from extension
  error      String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([shopId])
  @@index([status])
}

// ============= TOURNAMENTS =============

enum TournamentStatus {
  DRAFT
  PUBLISHED
  REGISTRATION_CLOSED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

model Tournament {
  id              String           @id @default(cuid())
  title           String
  description     String?
  game            CardGame
  shopId          String
  shop            Shop             @relation(fields: [shopId], references: [id], onDelete: Cascade)
  date            DateTime
  time            String // e.g., "14:00"
  maxParticipants Int
  entryFee        Float? // Optional entry fee
  prizePool       String? // Description of prizes
  rules           String? // Tournament rules
  status          TournamentStatus @default(DRAFT)
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  registrations TournamentRegistration[]

  @@index([shopId])
  @@index([game])
  @@index([status])
  @@index([date])
}

model TournamentRegistration {
  id           String     @id @default(cuid())
  tournamentId String
  tournament   Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  userId       String
  user         User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  status       String     @default("CONFIRMED") // CONFIRMED, CANCELLED, WAITLIST
  createdAt    DateTime   @default(now())

  @@unique([tournamentId, userId])
  @@index([tournamentId])
  @@index([userId])
}

// ============= FEATURED LISTINGS (VETRINA) =============

model FeaturedListing {
  id         String     @id @default(cuid())
  listingId  String
  listing    ListingP2P @relation(fields: [listingId], references: [id], onDelete: Cascade)
  startDate  DateTime   @default(now())
  endDate    DateTime
  tier       String     @default("BASIC") // BASIC (3 days), PREMIUM (1 week)
  amountPaid Float
  isActive   Boolean    @default(true)
  createdAt  DateTime   @default(now())

  @@index([listingId])
  @@index([endDate])
  @@index([isActive])
}

// ============= CHAT / MESSAGING =============

model Conversation {
  id        String   @id @default(cuid())
  userAId   String
  userA     User     @relation("ConversationUserA", fields: [userAId], references: [id], onDelete: Cascade)
  userBId   String
  userB     User     @relation("ConversationUserB", fields: [userBId], references: [id], onDelete: Cascade)
  listingId String? // Optional - conversation about a listing
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  messages Message[]

  @@unique([userAId, userBId])
  @@index([userAId])
  @@index([userBId])
}

model Message {
  id             String       @id @default(cuid())
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  senderId       String
  sender         User         @relation("Sender", fields: [senderId], references: [id], onDelete: Cascade)
  receiverId     String
  receiver       User         @relation("Receiver", fields: [receiverId], references: [id], onDelete: Cascade)
  content        String
  read           Boolean      @default(false)
  createdAt      DateTime     @default(now())

  @@index([conversationId])
  @@index([senderId])
  @@index([receiverId])
  @@index([read])
}

// ============= MERCHANT APPLICATION =============

enum ApplicationStatus {
  PENDING
  APPROVED
  REJECTED
}

model MerchantApplication {
  id          String            @id @default(cuid())
  userId      String            @unique
  user        User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  shopName    String // Nome azienda
  companyName String // Ragione sociale
  vatNumber   String // Partita IVA
  taxCode     String? // Codice fiscale
  uniqueCode  String? // Codice univoco azienda
  description String?
  address     String
  city        String
  province    String? // Provincia
  postalCode  String? // CAP
  phone       String
  email       String? // Email aziendale
  website     String? // Sito web
  documentUrl String? // Business license or ID
  legalForm   String? // Forma giuridica (SRL, SNC, ecc.)
  status      ApplicationStatus @default(PENDING)
  reviewNotes String? // Admin notes
  reviewedAt  DateTime?
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  @@index([status])
  @@index([createdAt])
  @@index([vatNumber])
}

// ============= ESCROW SYSTEM =============

enum EscrowSessionStatus {
  ACTIVE
  COMPLETED
  CANCELLED
  DISPUTED
}

enum FeePaidBy {
  SELLER // Fee detratta dal venditore (dal prezzo di vendita)
  BUYER // Fee aggiunta e pagata dal compratore
  SPLIT // Fee divisa 50/50 tra venditore e compratore
}

enum EscrowPaymentStatus {
  PENDING // Payment initiated but not confirmed
  HELD // Funds held in escrow
  RELEASED // Funds released to seller
  REFUNDED // Funds refunded to buyer
  CANCELLED // Payment cancelled
}

enum EscrowPaymentMethod {
  CASH // Cash payment at store
  ONLINE // Online payment (future)
  BANK_TRANSFER // Bank transfer (future)
}

// Escrow Session - Connects buyer, seller, and merchant in a communication session
model EscrowSession {
  id            String               @id @default(cuid())
  transactionId String               @unique
  transaction   SafeTradeTransaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)

  // Participants
  buyerId    String // User A (proposer)
  buyer      User   @relation("EscrowBuyer", fields: [buyerId], references: [id], onDelete: Cascade)
  sellerId   String // User B (receiver)
  seller     User   @relation("EscrowSeller", fields: [sellerId], references: [id], onDelete: Cascade)
  merchantId String // Shop owner
  merchant   User   @relation("EscrowMerchant", fields: [merchantId], references: [id], onDelete: Cascade)

  status EscrowSessionStatus @default(ACTIVE)

  // Payment & Fee Management
  totalAmount   Float               @default(0) // Prezzo totale concordato
  feePercentage Float               @default(5.0) // Percentuale fee (default 5%)
  feePaidBy     FeePaidBy           @default(SELLER) // Chi paga la fee
  feeAmount     Float               @default(0) // Fee calcolata
  finalAmount   Float               @default(0) // Importo finale (dopo fee)
  paymentMethod EscrowPaymentMethod @default(CASH) // Solo CASH per ora

  // QR Code for in-store verification
  qrCode      String?   @unique // Codice univoco per QR (nullable per record esistenti)
  qrScannedAt DateTime? // Timestamp quando il QR è stato scannerizzato
  qrScannedBy String? // ID del merchant che ha scannerizzato

  // Session metadata
  lastActivity DateTime @default(now())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  messages EscrowMessage[]

  @@index([transactionId])
  @@index([buyerId])
  @@index([sellerId])
  @@index([merchantId])
  @@index([status])
  @@index([qrCode])
  @@index([lastActivity])
}

// Messages within escrow session
model EscrowMessage {
  id        String        @id @default(cuid())
  sessionId String
  session   EscrowSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  senderId  String
  sender    User          @relation("EscrowMessageSender", fields: [senderId], references: [id], onDelete: Cascade)
  content   String
  isSystem  Boolean       @default(false) // System messages (e.g., "Payment received")
  readBy    String[] // Array of user IDs who read this message
  createdAt DateTime      @default(now())

  @@index([sessionId])
  @@index([senderId])
  @@index([createdAt])
}

// Escrow Payment - Manages funds in escrow
model EscrowPayment {
  id            String               @id @default(cuid())
  transactionId String               @unique
  transaction   SafeTradeTransaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)

  // Payment details
  amount        Float // Total amount in escrow
  currency      String              @default("EUR")
  paymentMethod EscrowPaymentMethod @default(CASH)
  status        EscrowPaymentStatus @default(PENDING)

  // Payment tracking
  paymentInitiatedAt DateTime? // When payment was initiated
  paymentHeldAt      DateTime? // When funds were held
  paymentReleasedAt  DateTime? // When funds were released to seller
  paymentRefundedAt  DateTime? // When funds were refunded

  // Payment references (for online payments)
  paymentProviderId String? // External payment provider transaction ID
  paymentProvider   String? // e.g., "stripe", "paypal"

  // Security & fraud prevention
  riskScore        Float? // Risk assessment score (0-100)
  flaggedForReview Boolean @default(false)
  reviewNotes      String? // Admin review notes

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([transactionId])
  @@index([status])
  @@index([paymentProviderId])
  @@index([flaggedForReview])
}

// Escrow Wallet - User's escrow balance (for future online payments)
model EscrowWallet {
  id     String @id @default(cuid())
  userId String @unique
  user   User   @relation("EscrowWallet", fields: [userId], references: [id], onDelete: Cascade)

  balance        Float @default(0) // Available balance
  pendingBalance Float @default(0) // Funds in pending transactions
  totalDeposited Float @default(0) // Total ever deposited
  totalWithdrawn Float @default(0) // Total ever withdrawn

  // Security
  isActive     Boolean  @default(true)
  lastActivity DateTime @default(now())

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  transactions EscrowWalletTransaction[]

  @@index([userId])
}

enum EscrowWalletTransactionType {
  DEPOSIT
  WITHDRAWAL
  ESCROW_HOLD // Funds held for transaction
  ESCROW_RELEASE // Funds released from escrow
  ESCROW_REFUND // Funds refunded from escrow
}

// Wallet transaction history
model EscrowWalletTransaction {
  id       String       @id @default(cuid())
  walletId String
  wallet   EscrowWallet @relation(fields: [walletId], references: [id], onDelete: Cascade)

  type        EscrowWalletTransactionType
  amount      Float
  description String?

  // Reference to related transaction/payment
  relatedTransactionId String? // SafeTradeTransaction ID
  relatedPaymentId     String? // EscrowPayment ID

  balanceBefore Float
  balanceAfter  Float

  createdAt DateTime @default(now())

  @@index([walletId])
  @@index([type])
  @@index([createdAt])
  @@index([relatedTransactionId])
}

// ============= PROMOTIONS =============

enum DiscountType {
  PERCENTAGE
  FIXED_AMOUNT
}

model Promotion {
  id            String       @id @default(cuid())
  shopId        String
  shop          Shop         @relation(fields: [shopId], references: [id], onDelete: Cascade)
  title         String
  description   String?
  discountType  DiscountType
  discountValue Float
  startDate     DateTime
  endDate       DateTime
  isActive      Boolean      @default(true)
  appliesTo     String[] // "ALL", "PRODUCTS", "LISTINGS"
  targetIds     String[] // IDs of specific items if appliesTo is specific
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt

  @@index([shopId])
  @@index([isActive])
  @@index([startDate])
  @@index([endDate])
}

// ============= COMMUNITY SYSTEM =============

model Topic {
  id          String   @id @default(cuid())
  slug        String   @unique
  name        String
  description String?
  icon        String? // Material symbol name
  posts       Post[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Premium Community (Insider Circle)
  isPremiumOnly Boolean @default(false)
  requiredTier  String? // "PREMIUM", "PRO", null = public
}

model Post {
  id        String    @id @default(cuid())
  title     String
  content   String    @db.Text
  topicId   String
  topic     Topic     @relation(fields: [topicId], references: [id], onDelete: Cascade)
  authorId  String
  author    User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  comments  Comment[]
  views     Int       @default(0)
  isPinned  Boolean   @default(false)
  isLocked  Boolean   @default(false)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  // Karma & Moderation System
  upvotes        Int     @default(0)
  downvotes      Int     @default(0)
  spamScore      Float   @default(0) // 0-1, higher = more likely spam
  isAutoApproved Boolean @default(false) // Auto-approved se karma utente > 50
  isFlagged      Boolean @default(false)
  flagReason     String?
  karmaChange    Int     @default(0) // Karma gained/lost from this post

  @@index([topicId])
  @@index([authorId])
  @@index([createdAt])
  @@index([isFlagged])
}

model Comment {
  id        String    @id @default(cuid())
  content   String    @db.Text
  postId    String
  post      Post      @relation(fields: [postId], references: [id], onDelete: Cascade)
  authorId  String
  author    User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  parentId  String? // For nested comments
  parent    Comment?  @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies   Comment[] @relation("CommentReplies")
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  @@index([postId])
  @@index([authorId])
  @@index([parentId])
}

// ============= BADGES SYSTEM =============

model Badge {
  id          String      @id @default(cuid())
  name        String      @unique
  description String?
  icon        String // Material symbol or image URL
  color       String      @default("blue") // e.g., "blue", "red", "gold"
  users       UserBadge[]
  createdAt   DateTime    @default(now())
}

model UserBadge {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  badgeId   String
  badge     Badge    @relation(fields: [badgeId], references: [id], onDelete: Cascade)
  awardedAt DateTime @default(now())

  @@unique([userId, badgeId])
}

// ============= SUBSCRIPTION SYSTEM =============

enum SubscriptionTier {
  FREE
  PREMIUM
  PRO
}

enum SubscriptionStatus {
  ACTIVE
  CANCELLED
  EXPIRED
  PAST_DUE
}

enum BillingPeriod {
  MONTHLY
  YEARLY
}

model SubscriptionPlan {
  id           String           @id @default(cuid())
  name         String           @unique // "FREE", "PREMIUM", "PRO"
  tier         SubscriptionTier
  description  String?
  priceMonthly Float            @default(0)
  priceYearly  Float            @default(0)

  // Features
  earlyAccessHours     Int     @default(0) // 0 = no early access, 24 = 24h head start
  maxAlerts            Int     @default(3) // Max price alerts
  prioritySafeTrade    Boolean @default(false)
  instantNotifications Boolean @default(false)
  premiumCommunity     Boolean @default(false)
  bulkListingTools     Boolean @default(false)
  priorityMonthlyLimit Int     @default(0) // Free priority SafeTrades per month

  subscriptions UserSubscription[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model UserSubscription {
  id     String           @id @default(cuid())
  userId String           @unique
  user   User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  planId String
  plan   SubscriptionPlan @relation(fields: [planId], references: [id])

  status        SubscriptionStatus @default(ACTIVE)
  billingPeriod BillingPeriod      @default(MONTHLY)

  // Dates
  startDate   DateTime  @default(now())
  endDate     DateTime? // null = never expires (lifetime or free)
  cancelledAt DateTime?

  // Payment tracking (for future Stripe integration)
  stripeCustomerId     String?
  stripeSubscriptionId String?
  lastPaymentAt        DateTime?
  nextPaymentAt        DateTime?

  // Usage tracking
  priorityUsedThisMonth Int @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([planId])
  @@index([status])
  @@index([endDate])
}

// ============= KARMA SYSTEM =============

enum KarmaLevel {
  NEW // 0-49 karma
  TRUSTED // 50-199 karma
  ELITE // 200-499 karma
  LEGEND // 500+ karma
  BANNED // < 0 karma
}

model UserKarma {
  id     String @id @default(cuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  karma Int        @default(0)
  level KarmaLevel @default(NEW)

  // Activity tracking
  postsCount      Int @default(0)
  commentsCount   Int @default(0)
  upvotesGiven    Int @default(0)
  upvotesReceived Int @default(0)
  flagsReceived   Int @default(0)

  // Rate limiting
  lastPostAt    DateTime?
  postsToday    Int       @default(0)
  lastResetDate DateTime  @default(now())

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([karma])
  @@index([level])
}

// ============= PRICE ALERTS SYSTEM =============

model PriceAlert {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Alert conditions (any combination)
  cardName  String? // Specifica carta (fuzzy match)
  cardSet   String? // Specifico set
  game      CardGame?
  maxPrice  Float? // Alert se prezzo < maxPrice
  minPrice  Float? // Alert se prezzo > minPrice (for selling)
  rarity    String? // Alert per rarità
  condition CardCondition?

  // Notification settings
  notifyEmail Boolean @default(true)
  notifyPush  Boolean @default(false) // Solo Premium
  notifySMS   Boolean @default(false) // Solo PRO

  isActive        Boolean   @default(true)
  lastTriggeredAt DateTime?
  triggerCount    Int       @default(0)

  triggers AlertTrigger[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([game])
  @@index([isActive])
  @@index([cardName])
}

model AlertTrigger {
  id        String     @id @default(cuid())
  alertId   String
  alert     PriceAlert @relation(fields: [alertId], references: [id], onDelete: Cascade)
  listingId String
  listing   ListingP2P @relation(fields: [listingId], references: [id], onDelete: Cascade)

  matchedPrice     Float
  notificationSent Boolean @default(false)

  triggeredAt DateTime @default(now())

  @@index([alertId])
  @@index([listingId])
  @@index([triggeredAt])
}

// ============= EVENTS CALENDAR SYSTEM =============

enum EventType {
  TOURNAMENT
  MEETUP
  RELEASE_PARTY
  TRADE_NIGHT
  PREMIUM_EVENT
  OTHER
}

enum EventStatus {
  DRAFT
  PUBLISHED
  CANCELLED
  COMPLETED
}

model CommunityEvent {
  id          String    @id @default(cuid())
  title       String
  description String?   @db.Text
  type        EventType
  game        CardGame?

  // Organizer (can be User or Shop)
  organizerUserId String?
  organizerShopId String?

  // Event details
  date       DateTime
  endDate    DateTime? // For multi-day events
  time       String? // e.g., "14:00"
  location   String? // Address or "Online"
  isOnline   Boolean   @default(false)
  onlineLink String? // Zoom/Discord link

  // Capacity
  maxParticipants Int?
  entryFee        Float?

  // Premium features
  isPremiumOnly Boolean @default(false)
  requiredTier  String? // "PREMIUM", "PRO"

  // Community integration
  discussionTopicId String? // Auto-create topic for discussion

  status EventStatus @default(DRAFT)

  registrations EventRegistration[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([type])
  @@index([game])
  @@index([date])
  @@index([status])
  @@index([isPremiumOnly])
}

model EventRegistration {
  id      String         @id @default(cuid())
  eventId String
  event   CommunityEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)
  userId  String
  user    User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  status String @default("REGISTERED") // REGISTERED, WAITLIST, CANCELLED, ATTENDED

  // Premium priority tracking
  isPriorityRegistration Boolean @default(false)

  createdAt DateTime @default(now())

  @@unique([eventId, userId])
  @@index([eventId])
  @@index([userId])
  @@index([status])
}

// ============= CONTACT SUPPORT MESSAGES =============

enum ContactStatus {
  PENDING
  READ
  REPLIED
  CLOSED
}

model ContactMessage {
  id         String        @id @default(cuid())
  userId     String? // Can be null for anonymous users
  user       User?         @relation("ContactMessages", fields: [userId], references: [id], onDelete: SetNull)
  email      String // Email for reply
  name       String // Name of sender
  subject    String
  message    String        @db.Text
  status     ContactStatus @default(PENDING)
  adminReply String?       @db.Text
  repliedAt  DateTime?
  repliedBy  String? // Admin user ID who replied
  ipAddress  String? // For rate limiting anonymous users
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt

  @@index([userId])
  @@index([email])
  @@index([status])
  @@index([createdAt])
}

// ============= SISTEMA APPROVAZIONE MANUALE RILASCIO FONDI =============

enum PendingReleaseType {
  RELEASE_TO_SELLER   // Rilascio fondi al venditore
  REFUND_FULL         // Rimborso totale al buyer
  REFUND_PARTIAL      // Rimborso parziale
  HUB_COMMISSION      // Commissione Hub Provider
  WITHDRAWAL          // Prelievo wallet
}

enum PendingReleaseStatus {
  PENDING             // In attesa di approvazione
  APPROVED            // Approvato e processato
  REJECTED            // Rifiutato
  EXPIRED             // Scaduto senza azione
}

model PendingRelease {
  id              String              @id @default(cuid())
  
  // Riferimenti
  orderId         String?
  order           SafeTradeTransaction? @relation("PendingReleases", fields: [orderId], references: [id], onDelete: SetNull)
  disputeId       String?
  dispute         Dispute?            @relation("PendingReleaseDispute", fields: [disputeId], references: [id], onDelete: SetNull)
  
  // Dettagli rilascio
  type            PendingReleaseType
  amount          Float
  recipientId     String
  recipient       User                @relation("PendingReleaseRecipient", fields: [recipientId], references: [id], onDelete: Cascade)
  recipientType   String              // 'SELLER', 'BUYER', 'HUB'
  
  // Status
  status          PendingReleaseStatus @default(PENDING)
  
  // Motivo/contesto
  reason          String?             @db.Text
  triggeredBy     String?             // 'DELIVERY_CONFIRMED', 'HUB_VERIFIED', 'DISPUTE_RESOLVED', 'WITHDRAWAL_REQUEST'
  triggeredAt     DateTime            @default(now())
  
  // Token conferma doppia (valido 5 minuti)
  confirmationToken String?           @unique
  tokenExpiresAt    DateTime?
  
  // Approvazione
  approvedById    String?
  approvedBy      User?               @relation("PendingReleaseApprover", fields: [approvedById], references: [id], onDelete: SetNull)
  approvedAt      DateTime?
  approvalNotes   String?             @db.Text
  
  // Rifiuto
  rejectedById    String?
  rejectedBy      User?               @relation("PendingReleaseRejecter", fields: [rejectedById], references: [id], onDelete: SetNull)
  rejectedAt      DateTime?
  rejectionReason String?             @db.Text
  
  // Audit
  auditLog        FinancialAuditLog?  @relation("PendingReleaseAudit")
  
  createdAt       DateTime            @default(now())
  expiresAt       DateTime?           // Opzionale: scadenza se non processato
  
  @@index([status])
  @@index([type])
  @@index([recipientId])
  @@index([orderId])
  @@index([createdAt])
}

// Log Audit per tutte le azioni finanziarie
model FinancialAuditLog {
  id                  String    @id @default(cuid())
  
  // Tipo azione
  actionType          String    // 'RELEASE_APPROVED', 'RELEASE_REJECTED', 'REFUND_APPROVED', etc.
  
  // Riferimenti
  pendingReleaseId    String?   @unique
  pendingRelease      PendingRelease? @relation("PendingReleaseAudit", fields: [pendingReleaseId], references: [id], onDelete: SetNull)
  orderId             String?
  
  // Dettagli finanziari
  amount              Float
  recipientId         String?
  
  // Chi ha eseguito l'azione
  performedById       String
  performedBy         User      @relation("AuditPerformer", fields: [performedById], references: [id], onDelete: Cascade)
  performedByRole     String    // 'ADMIN', 'MODERATOR'
  
  // Sicurezza e tracciabilità
  ipAddress           String?
  userAgent           String?   @db.Text
  
  // Timestamp doppia conferma
  firstClickAt        DateTime
  confirmClickAt      DateTime
  
  notes               String?   @db.Text
  
  createdAt           DateTime  @default(now())
  
  @@index([actionType])
  @@index([performedById])
  @@index([createdAt])
  @@index([orderId])
}

// Notifiche per Admin/Moderator
enum AdminNotificationType {
  PENDING_RELEASE     // Nuovo rilascio in attesa
  DISPUTE_ESCALATED   // Dispute escalata
  WITHDRAWAL_REQUEST  // Richiesta prelievo
  HUB_VERIFICATION    // Hub ha verificato pacco
  URGENT_ACTION       // Azione urgente richiesta
}

enum NotificationPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

model AdminNotification {
  id              String                  @id @default(cuid())
  
  type            AdminNotificationType
  referenceType   String                  // 'PENDING_RELEASE', 'DISPUTE', 'ORDER'
  referenceId     String
  
  title           String
  message         String                  @db.Text
  priority        NotificationPriority    @default(NORMAL)
  
  // Targeting (quali ruoli devono vedere)
  targetRoles     String[]                @default(["ADMIN", "MODERATOR"])
  
  // Tracking lettura
  readByIds       String[]                @default([])
  
  // Azione presa
  actionedById    String?
  actionedBy      User?                   @relation("NotificationActioner", fields: [actionedById], references: [id], onDelete: SetNull)
  actionedAt      DateTime?
  
  createdAt       DateTime                @default(now())
  
  @@index([type])
  @@index([priority])
  @@index([createdAt])
}

// ============= SISTEMA DISPUTE =============

enum DisputeStatus {
  OPEN              // Dispute aperta
  SELLER_RESPONSE   // In attesa risposta seller
  IN_MEDIATION      // In mediazione admin
  RESOLVED          // Risolta
  ESCALATED         // Escalation ad admin senior
  CLOSED            // Chiusa
}

enum DisputeType {
  NOT_DELIVERED     // Pacco non arrivato
  DAMAGED_CARDS     // Carte danneggiate
  WRONG_CONTENT     // Contenuto errato
  MISSING_ITEMS     // Articoli mancanti
  CONDITION_MISMATCH // Condizione non conforme
  DELAY             // Ritardo eccessivo
  OTHER             // Altro
}

enum DisputeResolution {
  REFUND_FULL       // Rimborso totale buyer
  REFUND_PARTIAL    // Rimborso parziale
  REPLACEMENT       // Sostituzione
  RETURN_REQUIRED   // Reso richiesto
  REJECTED          // Dispute rifiutata
  IN_FAVOR_BUYER    // A favore buyer
  IN_FAVOR_SELLER   // A favore seller
}

model Dispute {
  id              String            @id @default(cuid())
  transactionId   String
  transaction     SafeTradeTransaction @relation("Disputes", fields: [transactionId], references: [id], onDelete: Cascade)
  
  // Dispute Details
  type            DisputeType
  status          DisputeStatus     @default(OPEN)
  title           String
  description     String            @db.Text
  openedById      String
  openedBy        User              @relation("DisputeOpener", fields: [openedById], references: [id], onDelete: Cascade)
  
  // Resolution
  resolution      DisputeResolution?
  resolutionNotes String?           @db.Text
  resolutionAmount Float?           // Importo rimborso se parziale
  resolvedById    String?
  resolvedAt      DateTime?
  
  // Mediation
  mediatorId      String?
  mediationNotes  String?           @db.Text
  mediationDeadline DateTime?
  
  // Evidence
  photos          String[]          // Foto documentazione
  documents       String[]          // Documenti allegati
  
  // Timeline
  sellerResponseDeadline DateTime?  // 48h per rispondere
  openedAt        DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  closedAt        DateTime?
  
  // Relations
  messages        DisputeMessage[]
  pendingReleases PendingRelease[]  @relation("PendingReleaseDispute")
  
  @@index([transactionId])
  @@index([status])
  @@index([type])
  @@index([openedById])
}

model DisputeMessage {
  id          String    @id @default(cuid())
  disputeId   String
  dispute     Dispute   @relation(fields: [disputeId], references: [id], onDelete: Cascade)
  senderId    String
  sender      User      @relation("DisputeMessageSender", fields: [senderId], references: [id], onDelete: Cascade)
  content     String    @db.Text
  photos      String[]  // Foto aggiuntive
  isInternal  Boolean   @default(false) // Messaggio interno admin
  createdAt   DateTime  @default(now())
  
  @@index([disputeId])
  @@index([senderId])
}

// ============= ASSICURAZIONE PACCHI =============

enum InsuranceStatus {
  NOT_INSURED      // Nessuna assicurazione
  ACTIVE           // Assicurazione attiva
  CLAIMED          // Sinistro dichiarato
  SETTLED          // Sinistro risolto
  EXPIRED          // Scaduta
}

model PackageInsurance {
  id                String              @id @default(cuid())
  transactionId     String              @unique
  transaction       SafeTradeTransaction @relation("PackageInsurance", fields: [transactionId], references: [id], onDelete: Cascade)
  
  // Insurance Details
  insuredValue      Float               // Valore assicurato
  premiumAmount     Float               // Premio pagato
  coverageType      String              @default("STANDARD") // STANDARD, PREMIUM
  status            InsuranceStatus     @default(ACTIVE)
  
  // Premium Calculation
  baseRate          Float               @default(2.0) // Percentuale base (2%)
  riskFactor        Float               @default(1.0) // Fattore rischio (1.0-2.0)
  
  // Claim Details (se sinistro)
  claimAmount       Float?              // Importo sinistro richiesto
  claimReason       String?             @db.Text
  claimPhotos       String[]            // Foto documentazione sinistro
  claimSubmittedAt  DateTime?
  claimSettledAt    DateTime?
  claimSettledAmount Float?
  claimNotes        String?             @db.Text
  
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  
  @@index([transactionId])
  @@index([status])
}

// ============= MULTI-PACKAGE SYSTEM =============

model Package {
  id              String              @id @default(cuid())
  transactionId   String
  transaction     SafeTradeTransaction @relation("Packages", fields: [transactionId], references: [id], onDelete: Cascade)
  
  // Package Details
  packageNumber   Int                 // Numero pacco nella transazione (1, 2, 3...)
  sellerId        String              // Seller che ha inviato questo pacco
  seller          User                @relation("PackageSeller", fields: [sellerId], references: [id], onDelete: Cascade)
  
  // Tracking
  trackingNumber  String?             // Tracking pacco verso hub
  status          HubPackageStatus    @default(PENDING)
  
  // Timestamps
  receivedAt      DateTime?
  verifiedAt      DateTime?
  shippedAt       DateTime?
  deliveredAt     DateTime?
  
  // Verification
  verificationPhotos String[]         // Foto verifica questo pacco
  verifiedById       String?          // Hub provider ID
  
  // Value
  packageValue    Float               // Valore questo pacco
  
  // Consolidation
  isConsolidated  Boolean             @default(false)
  consolidationGroupId String?        // ID gruppo consolidazione
  
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt
  
  @@index([transactionId])
  @@index([sellerId])
  @@index([status])
  @@unique([transactionId, packageNumber])
}

model PackageConsolidation {
  id              String              @id @default(cuid())
  transactionId   String
  transaction     SafeTradeTransaction @relation("Consolidations", fields: [transactionId], references: [id], onDelete: Cascade)
  
  // Consolidation Details
  packageIds      String[]            // IDs dei pacchi consolidati
  totalValue      Float               // Valore totale consolidato
  
  // Shipping
  consolidatedTrackingNumber String?  // Tracking pacco consolidato
  consolidatedAt  DateTime?
  shippedAt       DateTime?
  
  // Cost Savings
  individualShippingCost Float        // Costo spedizioni separate
  consolidatedShippingCost Float      // Costo spedizione consolidata
  savingsAmount   Float               // Risparmio
  
  status          String              @default("PENDING") // PENDING, READY, SHIPPED, DELIVERED
  
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt
  
  @@index([transactionId])
}
